[{"content":"   복잡한 모델이 간단한 모델보다 과적합될 가능성이 높다. 그리고 간단한 모델은 적은 수의 매개변수를 가진 모델. 복잡한 모델을 좀 더 간단하게 하는 방법으로 가중치 규제(Regularization)가 있습니다.\n무작위로 신경망의 유닛 누락시킨다 -\u0026gt; 더 작은 신경망 사용하는 것과 같다\n-\u0026gt; regularization 효과 -\u0026gt; 과적합 예방\n원리  무작위로 입력이 제거될 수 있다 한가지 특성에만 의존하면 안되겠다! 한 특성에 비중 두는 것 피하기 입력 노드들에 비중 나눠줌 (가중치 분산) 가중치의 squared norm 줄이는 효과 overfitting 방지 👍  \nL2 정규화와 비슷하지만 다른 입력값의 스케일에 따라 더 변형한다는 차이가 있다.\n주로 컴퓨터 비전에서 입력 크기 너무 크기 때문에 많이 쓰인다.\n단점 비용함수 J가 모든 반복에서 잘 정의되지 않는다\n🤷Why?\n무작위로 노드를 취소하다보니 경사하강법의 성능을 이중 확인한다면 실제 다시 확인하기 어렵기 때문\n","description":"regularization 기법 중...","id":2,"section":"posts","tags":["ml","regularization","딥러닝"],"title":"Dropout","uri":"https://www.bemore.dev/posts/ml/dropout/"},{"content":"가중치 규제?   복잡한 모델을 좀 더 간단한 모델로 만들어 과적합될 가능성을 낮추는 방법. 간단한 모델이란 적은 수의 매개변수를 가진 모델을 말한다.\n  L1 regularization(=L1 norm): 모든 가중치 w의 절대값 합계를 비용 함수에 추가.\n$$ L1_{regularization} = \\frac{\\lambda}{m} \\Sigma |W| = \\frac{\\lambda}{2m} ||w||_1 $$\n  L2 regularization(=L2 norm): 모든 가중치 w의 제곱합을 비용 함수에 추가.\n$$ L2_{regularization} = \\frac{1}{m} \\Sigma L(\\hat{y}^{(i)}, y^{(i)}) + \\frac{\\lambda}{2m} ||w||^2_2 $$\n  lambd는 규제의 강도를 정하는 하이퍼파라미터. lambd가 크다면 모델이 훈련 데이터에 대해서 적합한 매개 변수를 찾는 것보다 규제를 위해 추가된 항들을 작게 유지하는 것을 우선한다는 의미. (lambda는 파이썬 키워드이기 때문에 수식에서 람다는 lambd 변수명을 주로 사용)\nL2 규제는 L1 규제와는 달리 가중치들의 제곱을 최소화하므로 w의 값이 완전히 0이 되기보다는 0에 가까워지기는 경향을 띈다. L1 규제는 w가 희미해져(w벡터에 0이 많음) 어떤 특성들이 모델에 영향을 주고 있는지를 정확히 판단하고자 할 때 유용하지만 별로 도움이 안되서 많이는 안쓰임. 경험적으로는 L2 규제가 더 잘 동작하므로 L2 규제를 더 많이 쓴다.\nL2 규제는 \u0026ldquo;가중치 감쇠(weight decay)\u0026ldquo;라고도 불린다.\nTechnique 💊 Data Augmentation 오버 피팅은 더 많은 훈련 데이터를 가져와서 해결할 수 있다. 하지만 훈련 데이터 더 가져오는 거는 비싸거나 수집하기 어렵다. 데이터 증강은 데이터를 추가하는 것보다 덜 효과적이어도 비싸지 않고, 알고리즘에 데이터 더 제공하고 일반화를 통해 과적합을 줄일 수 있다.\n💊 Early Stopping J 비용함수를 최적화시키는 진행 중에 자르는 것 + 과적합 방지\n단점 머신러닝 과정은 w, b를 찾고 J(w, b) 최저 비용 구하기, overfit 방지 이 두 과정이다. 이 두 과정은 각각 따로 생각하고 맞는 방법을 선택한다. 하지만 early stopping은 이 두 과정을 묶어버린다. 이 두 과정을 별개로 각각 단독으로 풀 수 없게 되고, 따라서 시도해야 할 방법이 더 복잡해진다.\n대안 L2 regularization으로 lambda값 시도하는 방법이 대안이다. 하지만 비용이 더 많이 들 수 있다.\n💊 Dropout 👉 Dropout 포스트\n참조 과적합을 막는 방법들\n","description":"overfitting을 막는 방법 중..💊","id":3,"section":"posts","tags":["ml","dls"],"title":"Regularization","uri":"https://www.bemore.dev/posts/ml/regularization/"},{"content":"Dataset Dataset ➡️ train / dev / test\n 데이터셋 비중\n이전에는 데이터셋 비중을 60% / 20% / 20% 을 이상적으로 생각했다. (10000개 정도 데이터에서는 이 비중이 이상적이지만)\n1000,000 이상의 빅데이터라면 1000,000/ 10000/ 1000. 즉, 98% / 1% / 1%.\n더 큰 데이터면 훈련 비중을 높이고 검증, 테스트 데이터셋 비중을 더 줄일 수 있다. 데이터 형태\n같은 배포에서 들어온 데이터로 하면 성능 더 높일 수 있다.  Bias / Variance example\n   훈련 데이터셋 오류율 검증 데이터셋 오류율      1% 11% high variance(overfitting)   15% 16% high bias(underfitting)   15% 30% high bias \u0026amp; high variance   0.5% 1% low bias \u0026amp; low variance    How to deal with bias, variance?   high bais?\n Bigger network Train loger NN 구조 손보기    high variance?\n More data Regularization NN 구조 손보기    ","description":"DLS Course2","id":4,"section":"posts","tags":["ml","dls"],"title":"Improving Deep Neural Network","uri":"https://www.bemore.dev/posts/ml/dls/course2_week1/"},{"content":"신경망에서 활성 함수로 쓰이는 비선형 함수들 🧨\nSigmoid $$ h(x) = \\frac{1}{1 + e^{-x}} $$\n1 2  def sigmoid(x): return 1 / (1 + np.exp(-x))   입력이 작을 떄의 출력은 0에 가깝고 입력이 커지면 출력이 1에 가까워진다.\n또한 출력이 클수록 기울기가 0에 가깝다.\nReLU $$ h(x) =\n\\cases{\n\\rm x \\qquad \\text{if }\\ x\\gt 0\\cr\n\\rm 0 \\qquad \\text{if }\\ x\\le 0\n} $$\n1 2  def relu(x): return np.maximum(0, x)   입력이 0을 넘으면 그 입력을 그대로 출력하고 0 이하면 0을 출력한다.\nLeaky ReLU $$ h(x) =\n\\cases{\n\\rm x \\qquad \\text{if }\\ x\\gt 0\\cr\n\\rm 0.01 \\times x \\qquad \\text{if }\\ x\\le 0\n} $$\n1 2  def leaky_relu(x): return np.maximum(0.01*x, x)   ReLU에서 0이하의 입력에 모두 0으로 출력하는데 이로 인해 발생하는 손실이 발생할 수 있다.\n반면 Leaky ReLU는 0이하의 입력을 0에 \u0026ldquo;근접\u0026quot;한 매우 작은 값으로 출력한다.\nTanh $$ h(x) = \\frac{e^x - e^{-x}}{e^x + e^{-x}} $$\n1 2  def tanh(x): return (np.exp(x) - np.exp(-x)) / (np.exp(x) + np.exp(-x))   🤷 왜 비선형 함수를 쓰는가? 선형함수를 쓴다면 층을 아무리 깊게 해도 하나의 층과 똑같을 수 있다\u0026hellip;도루묵\n예) h(x) = cx 로 3개 층을 쌓으면 y(x) = h(h(h(x))) = c * c * c * x = a * x\n따라서 층을 쌓은 효과를 얻기 위해서는 비선형 함수를 활성 함수로 써야한다.\n참고 밑바닥부터 시작하는 딥러닝\n","description":"활성함수","id":5,"section":"posts","tags":["ml"],"title":"Activation Function","uri":"https://www.bemore.dev/posts/ml/activationfunction/"},{"content":" 프로그래밍을 공부하고 실습할 때 가장 먼저 해보는 print(\u0026ldquo;Hello World\u0026rdquo;)\n데이터 사이언스를 공부할 때 Hello World 같은 데이터들은?\n Dataset   MNIST Dataset\n  Iris Project and Dataset\n  Titanic Project and Dataset\n  Housing Prices project and Dataset\n  House Prices\n  Credit Card Fraud Detection Project and Dataset\n  Fake News Detection Project and Dataset\n  COVID19 Tweets Project and Dataset\n  Air Pollution in Seoul\n  Hotel Booking Demand Datasets\n  The Movies Dataset\n  Mobile App Store ( 7200 apps)\n  Telco Customer Churn\n  NBA Players stats since 1950\n  Reference 이글은 캐글 초보자를 위한 친절한 가이드 글을 보고 정리했습니다.\n 캐글 초보자를 위한 10가지 팁 데이터 분석 어떻게 시작해야 하나요? 15 Machine Learning and Data Science Project Ideas with Datasets  ","description":"캐글에서 Hello World 같은 데이터셋","id":6,"section":"posts","tags":["ml","kaggle"],"title":"Hello World in Kaggle","uri":"https://www.bemore.dev/posts/ml/kaggle/hello-kaggle/"},{"content":"입력데이터 검증 및 표현\n1. SQL 삽입 😈 데이터베이스와 연동된 웹 응용 프로그램에서 입력된 데이터에 대한 유효성 검증을 하지 않을 경우 공격자가 입력 폼 및 입력란에 SQL문을 삽입하여 DB로부터 정보를 열람하거나 조작할 수 있는 보안취약점\nPython에서는 데이터베이스에 엑세스에 사용되는 다양한 Python 모듈간의 일관성을 장려하기 위해 DB-API를 정의해서 각 데이터베이스마다 별도의 DB 모듈을 이용해 데이터베이스에 엑세스하게 된다. DB-API 외에도, 파이썬에서는 ORM을 사용하여 데이터베이스에 엑세스할 수 있다.\nORM(Object RElation Mapping)을 이용하면 보다 안전하게 DB를 사용할 수 있지만 일부 복잡한 조건의 쿼리문 생성이 어렵고 성능저하 등의 이유로 쿼리의 튜닝이 필요한 경우 직접 원시 SQL 실행이 필요한 경우가 있다. ORM 대신 원시 쿼리를 사용하는 경우 검증되지 않은 외부 입력값으로 인해 SQL 삽입 공격이 발생할 수 있다.\n👮‍♀️ 시큐어 코딩  DB-API, 원시SQL: 매개변수화된 쿼리 사용하여 외부 입력값을 바인딩해서 사용하기 ORM(Django\u0026rsquo;s querySets, SQLALchemy, Storm): 따로 필요없음. ORM 프레임워크는 내부적으로 사용되는 쿼리 모든 곳에서 매개변수화된 명령문을 사용하므로 기본으로 SQL삽입 공격으로부터 보호된다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  from django.shortcuts import render def update_board(request): ...... with dbconn.cursor() as curs: name = request.POST.get(\u0026#39;name\u0026#39;, \u0026#39;\u0026#39;) content_id = request.POST.get(\u0026#39;content_id\u0026#39;, \u0026#39;\u0026#39;) # 😱 절망편: 사용자의 검증되지 않은 입력으로 부터 동적으로 쿼리문 생성 sql_query = \u0026#34;update board set name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39; where content_id=\u0026#39;“ + content_id + \u0026#34;\u0026#39;\u0026#34; # 😇 희망편: 외부 입력값으로 부터 안전한 매개변수 화된 쿼리를 생성 한다 sql_query = \u0026#39;update board set name= %swhere content_id=%s\u0026#39; # 😱 외부 입력값이 검증 없이 쿼리로 수행되어 안전하지 않다 curs.execute(sql_query) # 😇 사용자의 입력 값을 매개변수 화된 쿼리에 바인딩 하여 실행되므로 안전하다 curs.execute(sql_query, (name, content_id)) curs.commit() return render(request, \u0026#39;/success.html\u0026#39;)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  from django.shortcuts import render from app.models import Member def member_search(request): # 외부로부터 입력 값을 가져온다 name = request.POST.get(\u0026#39;name\u0026#39;, \u0026#39;\u0026#39;) # 😱 외부로부터 입력 받은 값을 검증 없이 쿼리문 생성에 사용하여 안전하지 않다 query=“select * from member where name=‘” + name + “’” # 😇 외부 입력 값을 raw()함수 실행 시 바인딩 변수로 사용하여 쿼리 구조가 변경되지 않도록 한다. (list 형은 %s, dictionary형은 %(key)s를 사용) query=\u0026#39;select * from member where name=%s\u0026#39; # 😱 raw() 외부 입력 값을 검증 없이 사용한 쿼리문을 함수로 실행하면 안전하지 않다 data = Member.objects.raw(query) # 😇 인자화된 쿼리문을 사용하여 raw()함수를 사용하여 안전 data = Member.objects.raw(query, [name]) return render(request, \u0026#39;/member_list.html\u0026#39;, {\u0026#39;member_list\u0026#39;:data})   2. 코드 삽입 프로그래밍 언어 자체의 기능에 한해 이뤄지며 취약한 프로그램에서 사용자의 입력 값에 코드가 포함되는 것을 허용할 경우, 공격자가 임의 코드를 삽입해 소프트웨어를 비정상적으로 동작시켜 공격자가 의도한 동작을 하도록 만드는 보안약점. 개발자가 의도하지 않은 코드를 실행하여 권한을 탈취하거나 인증 우회, 시스템 명령어 실행 등을 할 수 있다.\nPython에서 코드 삽입 공격을 유발할 수 있는 함수로 eval(), exec()등의 함수가 있다. 이 함수들을 사용할때 더욱 주의할것.\n👮‍♀️ 시큐어 코딩  동적코드를 실행할 수 있는 함수를 사용하지 않는다 or 실행 가능한 동적코드를 입력 값으로 받지 않도록하고 외부 입력값에 대하여 화이트리스트 방식으로 검증한다. 유효한 문자만 포함하도록 동적 코드에 사용되는 사용자 입력 값을 필터링   eval() 함수 사용 예제  1 2 3 4 5 6 7 8 9 10 11 12  from django.shortcuts import render def route(request): message = request.POST.get(\u0026#39;message\u0026#39;, \u0026#39;\u0026#39;) # 👿 eval함수에 외부 입력값을 검증 없이 사용할 경우 코드가 실행될 수 있어 위험 ret = eval(message) return render(request, \u0026#39;/success.html\u0026#39;, {\u0026#39;data\u0026#39;:ret}) # 😇 사용자 입력을 영문, 숫자로 제한. 특수문자가 포함되어 있을 경우 에러 메시지 리턴 if message.isalnum(): ret = eval(message) return render(request, \u0026#39;/success.html\u0026#39;, {\u0026#39;data\u0026#39;:ret})   예) Email 형식의 입력만 받아야할 경우 정규식으로 검증할 수 있다.\nprog = re.compile(r'([A-Za-z0-9]+[.-_])*[A-Za-z0-9]+@[A-Za-z0-9-]+(\\.[A-Z|a-z]{2,})+')\nexec()함수 사용 예제  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  from django.shortcuts import render WHITE_LIST = [\u0026#39;get_friends_list\u0026#39;, \u0026#39;get_address\u0026#39;, \u0026#39;get_phone_number\u0026#39;] def request_rest_api(request): function_name = request.POST.get(\u0026#39;function_name\u0026#39;, \u0026#39;\u0026#39;) # 👿 사용자에게 전달받은 함수명 검증하지 않고 실행 ret = exec(\u0026#39;{}()\u0026#39;.format(function_name)) return render(request, \u0026#39;/success\u0026#39;, {\u0026#39;data\u0026#39;:ret}) # 😇 함수명을 화이트리스트로 제한 if function_name in WHITE_LIST: ret = exec(\u0026#39;{}()\u0026#39;.format(function_name)) return render(request, \u0026#39;/success\u0026#39;, {\u0026#39;data\u0026#39;:ret}) return render(request, \u0026#39;/error\u0026#39;, {\u0026#39;error\u0026#39;:\u0026#39;허용되지 않은 함수입니다.\u0026#39;})   3. 경로 조직 및 자원 삽입 검증되지 않은 외부 입력값을 통해 파일 및 서버 등 시스템 자원(파일, 소켓의 포트 등)에 대한 접근 혹은 식별을 허용할 경우, 입력 값 조작을 통해 시스템이 보호하는 자원에 임의로 접근할 수 있는 보안약점. 공격자는 이를 통해 자원의 수정-삭제, 시스템 정보 누출, 시스템 자원간 충돌로 인한 서비스 장애를 유발시킬 수 있다.\nPython에서 주의해야할 점\n subprocess.popen()과 같이 프로세스를 여는 함수 os.pipe()처럼 파이프 socket 연결 등에서 외부 입력값을 검증 없이 사용할 경우  👮‍♀️ 시큐어 코딩  외부의 입력 값을 자원의 식별자로 사용하는 경우, 적절한 검증을 거치도록 하거나, 사전에 정의된 리스트에서 선택되도록 한다. 외부의 입력이 파일명인 경우에는 경로 순회(directory traversal) 공격의 위험이 있는 문자(/, , .. 등)를 제거할 수 있는 필터 이용한다.   경로 조작 예제  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import os from django.shortcuts import render def get_info(request): # 외부로부터 파일명을 입력받고 있다 request_file = request.POST.get(\u0026#39;request_file\u0026#39;) filename, file_ext = os.path.splitext(request_file) file_ext = file_ext.lower() if file_ext not in [\u0026#39;.txt\u0026#39;, \u0026#39;.csv\u0026#39;]: return render(request, \u0026#39;/error.html\u0026#39;, {\u0026#39;error\u0026#39;:\u0026#39;파일을 열 수 없습니다\u0026#39;}) # 😇 파일명에서 경로 조작 문자열을 필터링 filename = filename.replace(\u0026#39;.\u0026#39;, \u0026#39;\u0026#39;) filename = filename.replace(\u0026#39;/\u0026#39;, \u0026#39;\u0026#39;) filename = filename.replace(\u0026#39;\\\\\u0026#39;, \u0026#39;\u0026#39;) with open(request_file) as f: data = f.read() return render(request, \u0026#39;/success.html\u0026#39;, {\u0026#39;data\u0026#39;:data})   자원 삽입 예제  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import socket from django.shortcuts import render ALLOW_PORT = [4000, 6000, 9000] def get_info(request): port = request.POST.get(\u0026#39;port\u0026#39;) # 😇 사용 가능한 포트 번호를 화이트리스트로 제한 if port not in ALLOW_PORT: return render(request, \u0026#39;/error\u0026#39;, {\u0026#39;error\u0026#39;:\u0026#39;소켓연결 실패\u0026#39;}) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((\u0026#39;127.0.0.1\u0026#39;, port)) ... return render(request, \u0026#39;/success\u0026#39;) return render(request, \u0026#39;/error\u0026#39;, {\u0026#39;error\u0026#39;:\u0026#39;소켓연결 실패\u0026#39;})   4. 크로스사이트 스크립트(XSS) Cross-site scripting Attacks\n웹사이트의 결함을 이용하여 악성코드(일반적으로 클라이언트 측 js사용)삽입하여 사용자에게 보내는 공격 방법. 일반적으로 애플리케이션 사용자를 목표로 삼는다.\n공격자가 웹 응용프로그램을 속여 사용자의 브라우저에서 실행할 수 있는 형식의 데이터를 보낼때 발생. 일반적인 HTML+공격자의 XSS코드 조합 뿐만 아니라 악성코드 다운로드, 플로그인 또는 미디어 콘텐츠를 이용하기도 한다. 입력 양식의 데이터 또는 서버에서 클라이언트 endpoint로 전달된 데이터가 적절한 검증 없이 사용자에게 표시되도록 허용하는 경우 발생.\n유형  Reflective XSS (Non-persistent XSS)\n공격 코드를 사용자 HTTP 요청에 삽입 -\u0026gt; 해당 공격 코드가 서버 응답 내용에 그대로 반사(Reflected)되어 브라우저에서 실행시키는 공격기법. 종종 악의적으로 제작된 링크를 클릭하도록 사용자를 속여 대상 사이트로 데이터를 보내도록 한다. 대부분 공개적으로 게시되거나 피싱(phishing) 이메일 또는 단축 URL, 모호한 URL에 매개 변수로 포함하는 방법이 쓰인다. Rersistent XSS (Stored XSS)\n신뢰할 수 없거나 확인되지 않은 사용자 입력이 대상 서버에 저장될 때 발생. 게시판 글, 댓글 또는 방문자 로그가 일반적인 공격 대상이 된다. 인증되거나 인증되지 않은 다른 사용자가 공격자의 악성 콘텐츠를 보게된다. SNS 및 회원 그룹에서 흔히 볼 수 있는거 같이 공개적으로 표시되는 프로필 페이지가 쉬운 공격 대상 중 하나이다. DOM 기반 XSS (Client-Side XSS)\n공격 스크립트가 포함된 악성 URL을 통해 전달되는 경우가 많다. 문선 개체 모델을 수정하여 브라우저에서 독립적으로 완전한 공격을 실행해서 웹 페이지에 있는 js의 검증 로직을 무효화한다.공격자는 세션 정보를 포함한 쿠키와 같은 개인 정보를 피해자의 컴퓨터에서 공격자에게 전송할 수 있다. 공격자는 피해자의 정보를 사용하여 웹 사이트에 악의적인 요청을 보낼 수 있다.  👮‍♀️ 시큐어 코딩  외부 입력값 또는 출력값에 스크립트가 삽입되지 못하도록 문자열 치환 함수를 사용하여 \u0026amp;\u0026lt;\u0026gt;*‘/()등을 \u0026amp; \u0026lt; \u0026gt; \u0026quot; ' / ( )로 치환하거나, html라이브러리의 escape()를 사용한다. HTML 태그를 허용하는 게시판에서는 허용되는 HTML 태그들을 화이트리스트로 만들어 해당 태그만 지원하도록 한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  from django.shortcusts import render from django.utils.safestring import mark_safe def profile_link(request): # 외부 입력값을 검증 없이 HTML 태그 생성의 인자로 사용 profile_url = request.POST.get(\u0026#39;profile_url\u0026#39;) profile_name = request.POST.get(\u0026#39;profile_name\u0026#39;) object_link = \u0026#39;\u0026lt;a href=\u0026#34;{}\u0026#34;\u0026gt;{}\u0026lt;/a\u0026gt;\u0026#39;.format(profile_url, profile_name) # 😱 mark_safe함수는 Django의 XSS escape 정책을 따르지 않는다 object_link = mark_safe(object_link) # 😇 mark_safe 함수 사용하지 않는다 return render(request, \u0026#39;my_profile.html\u0026#39;,{\u0026#39;object_link\u0026#39;:object_link})   템플릿 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; // 😱 autoescape off로 해당 블록내의 데이터는 XSS 공격에 노출될 수 있음 {% autoescape off %} {{ content }} {% endautoescape %} // 😇 autoescape on 로 해당 블록내의 데이터는 XSS 공격에 노출되지 않음 {% autoescape off %} {{ content }} {% endautoescape %} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content2\u0026#34;\u0026gt; // 😱 safe 필터 사용으로 XSS 공격에 노출될 수 있다 {{ content | safe }} // 😇 검증되지 않은 데이터에는 safe 필터 ❌ [{ content }] \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13  import html from flask import Flask, request, render_template @app.route(\u0026#39;/search\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def search(): seasrch_keyword = request.from.get(\u0026#39;search_keyword\u0026#39;) # 😱 사용자의 입력을 아무런 검증 없이 치환 없이 동적 웹 페이지에 사용하고 있다 return render_template(\u0026#39;search.html\u0026#39;, search_keyword=search_keyword) # 😇 동적 웹 페이지 생성ㅇ에 사용되는 데이터는 HTML 엔티티코드로 치환 escape_keyword = html.escape(search_keyword) return render_template(\u0026#39;search.html\u0026#39;, search_keyword=search_keyword)   5. 운영체제 명령어 삽입 검증을 거치지 않은 사용자 입력값이 운영체제 명령어의 일부 또는 전부로 구성되어 실행 -\u0026gt; 의도하지 않은 시스템 명령어가 실행 -\u0026gt; 부적절하게 권한이 변경되거나 시스템 동작, 운영에 악영향\n명령어 라인의 파라미터나 스트림 입력 등 외부 입력을 사용하여 시스템 명령어를 생성하는 프로그램 많이 있다. 하지만 이런 경우 외부 입력 문자열은 신뢰할 수 없기 때문에 적절한 처리를 해주지 않으면 보안에 취약하다.\nPython에서 주의할 점\nString으로 표현된 식을 인수로 받아 반환하는 eval() 함수 + 인수로 받은 문자열을 실행하는 exec() 함수를 같이 사용하면 여러 변수들에 동적으로 값을 할당하여 사용될 수 있어 취약하다.\n👮‍♀️ 시큐어 코딩  외부 입력값이 시스템 명령에 포함되는 경우 |, ;, \u0026amp;, :, \u0026gt;, \u0026lt;, `(backtick), , ! 과 같이 멀티라인 파이프 리다이렉트 문자 등을 필터링 하고 명령을 수행할 파일명, 옵션을 제한하여 인자로만 사용될 수 있도록 한다 외부 입력에 따라 명령어를 생성하 거나 선택이 필요한 경우에는 명령어 생성에 필요한 값 들을 미리 지정해 놓고 외부 입력에 따라 선택하여 사용한다.   os.system  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  import os from django.shortcuts import render # 화이트리스트의 파라미터 배열 정의 ALLOW_PROGRAM = [\u0026#39;notepad\u0026#39;, \u0026#39;calc\u0026#39;] def execute_command(request): app_name_string = request.POST.get(\u0026#39;app_name\u0026#39;) # 입력받은 파라미터 사용가능한 시스템 명령어 일부로 제한하여 사용 if app_name_string not in ALLOW_PROGRAM: return render(request, \u0026#39;/error.html\u0026#39;, {\u0026#34;ERROR\u0026#34;:\u0026#34;허용되지 않은 프로그램\u0026#34;}) os.system(app_name_string) return render(request, \u0026#39;/success.html\u0026#39;)   subprocess() 함수  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import subprocess from django.shortcuts import render def execute_command(request): date = request.POST.get(\u0026#39;date\u0026#39;, \u0026#39;\u0026#39;) # 😱 입력 파라미터를 제한하지 않아 전달된 모든 프로그램 실행될 수 있음 cmd_str = \u0026#34;cmd /c backuplog.bat \u0026#34; + data subprocess.run(cmd_str, shell=True) return render(request, \u0026#39;/success.html\u0026#39;) # 😇 명령어를 추가로 실행 or 다른 명령이 실행될 수 있는 키워드 예외처리 for word in [\u0026#39;|\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;:\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;!\u0026#39;]: date = date.replace(word, \u0026#39;\u0026#39;) subprocess.run([\u0026#34;cmd\u0026#34;, \u0026#34;/c\u0026#34;, \u0026#34;backuplog.bat\u0026#34;, date]) return render(request, \u0026#39;/success.html\u0026#39;)   6. 위험한 형식 파일 업로드 서버에서 실행될 수 있는 스크립트 파일(.asp, .jsp, .php, .sh 등)을 업로드 할 수 있고 공격자가 웹을 통해 직접 실행시킬 수 있는 경우 시스템 내부 명령어를 실행하거나 외부와 연결하여 시스템을 제어할 수 있는 보안 약점 👮‍♀️ 시큐어 코딩  특정 파일 유형만 허용하도록 화이트리스트 방식으로 파일 유형 제한  Content-Type도 확인 파일 크기 및 파일 개수 제한   업로드된 파일을 웹 루트 폴더 외부에 저장하여 공격자가 URL을 통해 파일을 실행할 수 없도록 한다 업로드 되는 파일 이름은 공격자가 추측할 수 없는 무작위한 이름으로 변경하여 저장 업로드된 파일 저장할 경우 최소 권한만 부여  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  import os from django.shortcuts import render from django.core.files.storage import FileSystemStorage # 업로드 하는 파일에 대한 개수, 크기, 확장자 제한 FILE_COUNT_LIMIT = 5 # 업로드 파일의 최대 사이즈 제한 FILE_SIZE_LIMIT = 5 * 1024 * 1024 # 화이트리스로 허용하는 확장자 관리 WHITE_LIST_EXT = [\u0026#39;.jpg\u0026#39;, \u0026#39;.jpeg\u0026#39;] def file_upload(request): if request.FILES[\u0026#39;upload_file\u0026#39;]: upload_file = request.FILES[\u0026#39;upload_file\u0026#39;] fs = FileSystemStorage(location=\u0026#39;media/screenshot\u0026#39;, base_url=\u0026#39;media/screenshot\u0026#39;) filename = fs.save(upload_file.name, upload_file) return render(request, \u0026#39;/success.html\u0026#39;, {\u0026#39;filename\u0026#39;:filename}) return render(request, \u0026#39;/error.html\u0026#39;, {\u0026#39;error\u0026#39;:\u0026#39;파일 업로드 실패\u0026#39;}) def file_upload(request): if len(request.FILES) == 0 or len(request.FILES) \u0026gt; FILE_COUNT_LIMIT: return render(request, \u0026#39;/error.html\u0026#39;) for filename, upload_file in request.FILES.items(): if upload_file.content_type != \u0026#39;image/jpeg\u0026#39;: return render(request, \u0026#39;/error.html\u0026#39;) if upload_file.size \u0026gt; FILE_SIZE_LIMIT: return render(request, \u0026#39;/error.html\u0026#39;) file_name, file_ext = os.path.splitext(upload_file.name) if file_ext.lower() not in WHITE_LIST_EXT: return render(request, \u0026#39;/error.html\u0026#39;) fs = FileSystemStorage(location=\u0026#39;media/screenshot\u0026#39;, base_url = \u0026#39;media/screenshot\u0026#39;) for upload_file in request.FILES.values(): fs.save(upload_file.name, upload_file) return render(request, \u0026#39;/success.html\u0026#39;, {\u0026#39;filename\u0026#39;: filename})   7. 신뢰되지 않는 URL주소로 자동접속 연결 클라이언트에서 전송된 URL 주소를 공격자는 해당 폼의 요청을 변조함으로써 사용자가 위험한 URL로 접속할 수 있도록 공격할 수 있다.\nredirect함수를 사용할때 해당 프레임워크 버전에서 알려진 취약점이 있는지 확인하기\n Flask 프레임워크에서 주의할 점  get_post_logout_redirect get_post_login_redirect    Flask-Security-Too 라이브러리 4.1.0 이전 버전에서 URL 유효성 검사를 우회하고 사용자를 임의의 URL로 리디렉션 할 수 있는 취약점 존재\n👮‍♀️ 시큐어 코딩  리디렉션 허용하는 모든 URL을 서버에서 화이트리스트로 관리하고 입력으로 받은 주소가 화이트리스트에 존재하는지 검증한다. 만약 사용자 입력 주소가 화이트리스트로 관리가 불가능하고 리디렉션 URL의 인자값으로 사용되어야만 하는 경우는 모든 리디렉션에서 프로토콜과 host정보가 들어가지 않는 상대경로를 사용하고 검증해야한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from django.shortcuts import redirect # 😇 화이트리스트로 리다이렉트 허용하는 웹사이트 정의 ALLOW_URL_LIST = [ \u0026#39;127.0.0.1\u0026#39;, \u0026#39;192.168.0.1\u0026#39;, \u0026#39;192.168.0.100\u0026#39;, \u0026#39;https://login.myservice.com\u0026#39;, \u0026#39;/notice\u0026#39; ] def redirect_url(request): url_string = request.POST.get(\u0026#39;url\u0026#39;, \u0026#39;\u0026#39;) # 😇 리다이렉트할 수 있는 URL 범위 제한 if url_string not in ALLOW_URL_LIST: return render(request, \u0026#39;/error.html\u0026#39;, {\u0026#39;ERROR\u0026#39;:\u0026#39;not allowed url\u0026#39;}) return redirect(url_string)   8. 부적절한 XML 외부 개체 참조 서버에서 XML 외부 엔티티를 처리할 수 있도록 설정된 경우 발생.\n취약한 XML parser가 외부 값을 참조하는 XML값을 처리할 때, 공격자가 삽입한 공격 구문이 동작되어 서버 파일 접근, 불필요한 자원 사용, 인증 우회, 정보 노출 등 발생할 수 있다.\n간단한 XML 데이터 구문 분석 및 조작에 사용할 수 있는 기본 XML parser가 제공되지만 유효성 검사같은 고급 XML 기능은 지원하지 않는다. 기본 제공되는 XML 파서는 외부 엔티티를 지원하지 않지만 다른 XML 공격에 취약할 수 있다.\n👮‍♀️ 시큐어 코딩  로컬 정적 DTD를 사용하도록 설정하고, 외부에서 전송된 XML 문서에 포함된 DTD를 완전하게 비활성화해야 한다. 비활성화를 할 수 없는 경우에는 외부 엔티티 및 외부 문서 유형 선언을 각 파서에 맞는 고유한 방식으로 비활성화 한다. 외부 라이브러리를 사용할 경우 기본적으로 외부 엔티티에 대한 구문 분석 기능을 제공하는지 확인하고 제공할 경우 해당 기능을 비활성화 할 수 있는 방법을 확인하여 외부 엔티티 구문 분석 기능을 비활성화 한다. 많이 사용하는 XML 파서의 한 종류인 lxml의 경우 외부 엔티티 구문 분석 옵션인 resolve_entities 옵션을 비활성화  외부 문서를 조회할 때 네트워크 액세스를 방지하는 no_network 옵션이 활성화(True) 되어 있는지도 확인    1 2 3 4 5 6 7  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ELEMENT foo ANY \u0026gt; \u0026lt;!ENTITY xxe1 SYSTEM \u0026#34;file:///etc/passwd\u0026#34; \u0026gt; \u0026lt;!ENTITY xxe2 SYSTEM \u0026#34;http://attacker.com/text.txt\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;foo\u0026gt;\u0026amp;xxe1;\u0026amp;xxe2;\u0026lt;/foo\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  from xml.sax import make_parser from xml.sax.handler import feature_external_ges from xml.dom.pulldom import parseString, START_ELEMENT from django.shortcuts import render from .model import comments def get_xml(request): if request.method == “GET”: data = comments.objects.all() com = data[0].comment return render(request, \u0026#39;/xml_view.html\u0026#39;, {\u0026#39;com\u0026#39;:com}) elif request.method == “POST”: parser = make_parser() # 😱 parser.setFeature(feature_external_ges, True) # 😇 텍스트 값을 엔트리로 변환하는 옵션 끄기 parser.setFeature(feature_external_ges, False) doc = parseString(request.body.decode(‘utf-8’), parser=parser) for event, node in doc: if event == START_ELEMENT and node.tagName == “foo”: doc.expandNode(node) text = node.toxml() comments.objects.filter(id=1).update(comment=text) return render(request, \u0026#39;/xml_view.html\u0026#39;)   9. XML 삽입 검증되지 않은 외부 입력값이 XQuery 또는 XPath 쿼리문을 생성하는 문자열로 사용되어 공격자가 쿼리문의 구조로 임의로 변경하고 임의의 쿼리를 실행하여 허가되지 않는 데이터를 열람하거나 인증 절차를 우회할 수 있는 보안약점 👮‍♀️ 시큐어 코딩 XQuery 또는 XPath 쿼리에 사용되는 외부 입력데이터에 대하여 특수문자 및 쿼리 예약어를 필터링 하고 파라미터화된 쿼리문을 지원하는 XQuery 사용하기\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  from lxml import etree def parse_xml(request): user_name = request.POST.get(\u0026#39;user_name\u0026#39;, \u0026#39;\u0026#39;) parser = etree.XMLParser(resolve_entities=False) tree = etree.parse(\u0026#39;user.xml\u0026#39;, parser) root = tree.getroot() # 😱 검증되지 않은 외부 입력값으로 안전하지 않은 질의문이 query변수에 저장 path = \u0026#34;/collection/users/user[@name=\u0026#39;\u0026#34; + user_name + \u0026#34;\u0026#39;]/home/text()\u0026#34; elmts = root.xpath(query) # 😇 외부 입력값을 매개변수화 elmts = root.xpath(query, paramname=user_name) return render(request, \u0026#39;parse_xml.html\u0026#39;, {\u0026#39;xml_element\u0026#39;:elmts})   10. LDAP 삽입 웹 응용프로그램이 사용자가 제공한 입력을 적절한 처리 없이 LDAP 쿼리문이나 결과의 일부로 사용하는 경우, 공격자가 외부 입력을 통해서 사용자가 의도하지 않은 LDAP 명령어를 수행할 수 있는 취약점.\n프로세스가 명령을 실행한 컴포넌트와 동일한 권한을 가지고 동작하게 된다.\nIdap3라이브러리가 python-Idap 보다 더 현대적인 라이브러리로 좀 더 Pythonic 방식으로 LDAP서버와 상호 작용할 수 있는 완전한 기능의 추상화 계층이 포함되어 있어 Idap3 라이브러리를 사용하는 것이 권장된다.\nLDAP? LDAP(Lightweight Directory Access Protocol)이란 네트워크상에서 조직이나 개인, 파일, 디바이스 등을 찾아볼 수 있게 해주는 소프트웨어 프로토콜\n알아두면 쓸데있는 LDAP (SAMSUNG SDS)\n👮‍♀️ 시큐어 코딩  올바른 인코딩 함수를 사용하여 모든 변수 escape 화이트릴스트 방식의 입력값 유효성 검사 사용자 비밀번호와 같은 민감한 정보가 포함된 필드 인덱싱 LDAP 바인딩 계정에 할당된 권한 최소화  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from idap3 import Connection, Server, ALL from django.shortcuts import render def Idap_query(request): search_keyword = request.POST.get(\u0026#39;search_keyword\u0026#39;, \u0026#39;\u0026#39;) dn = sever.config[\u0026#39;bind_dn\u0026#39;] password = server.config[\u0026#39;password\u0026#39;] address = \u0026#39;Idap.badSource.com\u0026#39; server = Server(address.get_info=ALL) conn = Connection(server, user=dn, password, auto_bind=True) # 😇 입력에 필터링을 적용하여 공격에 사용될 수 있는 문자를 이스케이프 escpae_keyword = escape_filter_chars(search_keyword) search_str = \u0026#39;(\u0026amp;(objectclass=%s))\u0026#39; % search_keyword conn.search(\u0026#39;dc=company,dc=com\u0026#39;, search_str, attributes=[\u0026#39;sn\u0026#39;, \u0026#39;cn\u0026#39;, \u0026#39;address\u0026#39;, \u0026#39;mail\u0026#39;, \u0026#39;mobile\u0026#39;, \u0026#39;uid\u0026#39;]) return render(request, \u0026#39;/ldap_query_response.html\u0026#39;, {\u0026#39;ldap\u0026#39;:conn.entries})   11. 크로스사이트 요청 위조 CSRF 세션이 의도치 않게 계속 유지되어 요청을 검증하지 못하는 경우 관리자 권한으로만 수행 가능한 기능이 공격자의 의도대로 실행될 수 있다.\nDjango, Flask 프레임워크 모두 CSRF 토큰 기능을 지원한다.\n Django: {% csrf token %} 태그 이용 Flask: Flask-WTF 확장 라이브러리를 통해 {{form.csrf_token}} 태그 이용  👮‍♀️ 시큐어 코딩 Django 프레임워크  미들웨어의 CSRF 옵션 유지  템플릿 페이지에서 {% csrf_token %}으로 csrf_token값 명시하기   템플릿에서 csrf_exempt 데코레이터를 사용❌\nviews.py 예시  Flask 1 2 3 4 5 6 7 8  from flask import Flask from flask_wtf.csrf import CSRFProtect # 😇 CSRF 설정 추가 csrf = CSRFProtect(app) app = Flask(__name__) app.config[‘SECRET_KEY’] = os.environ.get(\u0026#39;SECRET_KEY\u0026#39;) csrf.init_app(app)   템플릿 예시\n1 2 3 4 5 6 7 8  \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;!-- form 태그 내부에 csrf_token 적용--\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;csrf_token\u0026#34; value=\u0026#34;{{ csrf_token }}\u0026#34; /\u0026gt; \u0026lt;table\u0026gt; {{table}} \u0026lt;/table\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt;   12. 서버사이드 요청 위조 적절한 검증절차를 거치지 않은 상용자 입력값을 서버간의 요청에 사용하여 악의적인 행위가 발생할 수 있는 보안약점.\n공격자는 URL 또는 요청문을 위조하여 접근통제를 우회하는 방식으로 비정상적인 동작을 유도하거나 네트워크에 있는 데이터를 획득할 수 있다. 👮‍♀️ 시큐어 코딩  식별할 수 있는 범위 내 사용자 입력 값을 화이트리스트 방식으로 필터링 무작위 URL을 받아야한다면 내부 URL을 블랙리스트로 지정하여 필터링 동일한 내부 네트워크에 있더라도 기기 인증, 접근권한 확인  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  from django.shortcuts import render import requests # 도메인을 화이트리스트에 정의 할 경우 DNS rebinding 공격 등에 #노출될위험이있어신뢰할수있는자원에대한IP를사용하여 # 검증하는 것이 좀더 안전하다. ALLOW_SERVER_LIST = [ \u0026#39;https://127.0.0.1/latest/\u0026#39;, \u0026#39;https://192.168.0.1/user_data\u0026#39;, \u0026#39;https://192.168.0.100/v1/public\u0026#39; ] def call_third_party_api(request): addr = request.POST.get(\u0026#39;address\u0026#39;, \u0026#39;\u0026#39;) if addr not in ALLOW_SERVER_LIST: return render(request, \u0026#39;/error.html\u0026#39;, {error = \u0026#39;허용되지 않은 서버입니다.\u0026#39;}) result = requests.get(addr).text return render(request, \u0026#39;/result.html\u0026#39;, {\u0026#39;result\u0026#39;:result})   13. HTTP 응답분할 HTTP 요청에 있는 파라미터가 HTTP 응답헤더에 포함되어 사용자에게 다시 전달될 때, 입력값에 CR(CarriageReturn)이나 LF(LineFeed)같은 \u0026ldquo;개행문자\u0026quot;가 존재하면 HTTP 응답이 2개 이상으로 분리될 수 있다. 공격자는 이 경우 개행 문자를 이용하여 첫 번째 응답을 종료시키고 두번째 응답에 악의적인 코드를 주입하여 XSS 및 캐시 훼손 공격 등을 수행할 수 있다. 👮‍♀️ 시큐어 코딩  요청 파라미터의 값을 HTTP 응답헤더(예를 들어, Set-Cookie 등)에 포함시킬 경우 CR(\\r), LF(\\n)와 같은 개행문자를 제거한다. 외부 입력값이 헤더, 쿠키, 로그등에 사용될 경우에는 항상 개행 문자를 검증하고 헤더에 사용되는 예약어 등은 화이트리스트로 제한 할 수 있으면 화이트리스트로 제한하여야 한다.  14. 부적절한 입력값  👮‍♀️ 시큐어 코딩 15. 포맷 스트링 삽입  👮‍♀️ 시큐어 코딩 참고자료 Python 시큐어코딩 가이드(전자정부보호팀,2022.04.12)\nhttps://www.boho.or.kr/data/guideView.do?bulletin_writing_sequence=66641\n","description":"\u003cPython 시큐어코딩 가이드\u003e - KISA","id":7,"section":"posts","tags":["보안"],"title":"파이썬 시큐어코딩 가이드: 입력데이터 검증 및 표현","uri":"https://www.bemore.dev/posts/devstory/python_secure/"},{"content":"Prim Algorithm 크루스칼이 최소비용 간선을 선택해 나간다면, 프림 알고리즘은 최소비용 간선이 있는 정점을 선택해 나간다.     시간복잡도     우선순위 큐 $O(ElogV)$   인접행렬 $O(V^2)$      구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  import heapq INF = int(1e9) def prime(start): queue = [] heapq.heappush(queue, (0, start)) distance[start] = 0 while queue: dist, u = heapq.heappop(queue) for v, c in graph[u]: if c \u0026lt; distance[v]: distance[v] = c n, m = map(int, input().split()) # 노드, 간선 개수 start = int(input()) # 출발 노드 graph = [[] for _ in range(n+1)] distance = [INF] * (n+1) # 간선 정보 for _ in range(m): source, dest, cost = map(int, input().split()) graph[source].append((dest, cost)) prime(start) print(distance)   ","description":"Prim Algorithm","id":8,"section":"posts","tags":["알고리즘","그래프","최단경로"],"title":"프림 알고리즘","uri":"https://www.bemore.dev/posts/cs/algorithm/prim/"},{"content":"MST Spanning Tree: 최소한 간선을 사용하여 그래프 내 모든 정점을 이은 트리(트리는 사이클이 없다는거 주의)\nn개의 정점에 n-1개의 간선이 존재하는 그래프는 트리\n가중치가 있는 그래프에서 최소 비용을 사용하면 Minimum Spanning Tree\nUnion-Find 특정 원소들을 합칠때 이들이 같은 집합에 포함되어 있는지 확인하거나 두 집합을 합칠때 사용한다.\nKruskal Algorithm 최소비용 간선을 선택해나간다. 이때 사이클이 발생하지 않도록 하는데 그 과정에서 Union-Find를 사용하면 사이클이 발생하는지 체크할 수 있다.\n간선의 가중치가 작은 것부터 순서대로 보면서 해당 간선 양 끝에 있는 두 노드 x, y에 대해 find(x), find(y)값을 비교하여 일치하지 않는 경우에만 간선을 선택해주고 union(x, y)를 진행해주는 식으로 계속 진행한다.\n 시간복잡도: $O(ElogE)$    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  def find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x] def union_parent(parent, a, b): a = find_parent(parent, a) b = find_parent(parent, b) if a \u0026lt; b: parent[b] = a else: parent[a] = b def kruskal(edges): result = 0 # 간선을 비용이 작은 것부터 정렬 edges.sort() for edge in edges: cost, a, b = edge # 두 지점을 이었을때 사이클이 없으면 if find_parent(parent, a) != find_parent(parent, b): union_parent(parent, a, b) result += cost return result v, e = map(int, input().split()) # 정점, 간선 개수 parent = [i for i in range(v+1)] # 각 정점이 속한 그룹 초기화 edges = [] # 간선 정보 입력 for _ in range(e): a, b, cost = map(int, f.readline().split()) edges.append((cost, a, b))   ","description":"Kruskal Algorithm","id":9,"section":"posts","tags":["알고리즘","그래프","최단경로"],"title":"크루스칼 알고리즘","uri":"https://www.bemore.dev/posts/cs/algorithm/kruskal/"},{"content":"정규화 normalization\n이상현상이 발생하는 릴레이션을 분해하여 이를 없애는 과정.\n이상현상을 일으키는 함수 종속성의 유형에 따라 등급을 구분할 수 있다. 제 1 정규형 A relation in which the intersection of each row and column contains one and only one value.\n릴레이션의 모든 속성 값이 원자값을 가지면 제 1 정규형이라고 한다. 🛠 정규형 변환  학생 릴레이션\n  제 2 정규형 A relation that is in first normal form and every non-primary key attribute is fully functionally dependent on the primary key.\n릴레이션이 제 1 정규형이고 기본키가 아닌 속성이 기본키에 완전 함수 종속일 때 제 2 정규형이라고 한다.  완전 함수 종속?\nA와 B가 릴레이션의 속성이고 A -\u0026gt; B 종속성이 성립할 때, B가 A의 속성 전체에 함수 종속하고 부분 집합 속성에 함수 종속하지 않을 경우 완전 함수 종속이라고 한다.\n(학번, 강좌이름) -\u0026gt; 학점\n학번 -x-\u0026gt; 학점 and 강좌이름 -x-\u0026gt; 학점 불완전 함수 종속(부분 함수 종속)\n(학번, 강좌이름) -\u0026gt; 강의실에서 학번을 제거해도 강좌이름 -\u0026gt; 강의실 성립  😈 이상현상  학점 릴레이션\n   삭제이상: 202233 학생의 수강을 취소하면 작문 강좌의 정보가 사라진다 삽입이상: 새 강좌를 개설했을때 수강신청한 학생이 없으면 학생번호, 학점을 NULL값으로 삽입해야하는 문제 수정이상: 데이터베이스 강좌 강의실을 변경할 시 데이터 불일치기 발생할 수 있다  🗝 이상현상 원인 기본키가 아닌 속성(강의실)이 기본키에 완전 함수 종속이 아닌 불완전 함수 종속 되어 있으면 이상현상이 발생한다.\n예시 릴레이션의 기본키는 (학번, 강좌이름), 기본키가 아닌 속성은 성적, 강의실. 성적과 강의실은 모두 기본키(학번, 강좌이름)에 함수적으로 종속되어 있지만 강의실은 기본키의 부분집합인 강좌이름에 종속되어 있다.\n🛠 정규형 변환   제 3 정규형 A relation that is in first and second normal form and in which no non-primary key is transitively dependent on the primary key.\n제 2정규형이고 기본키가 아닌 속성이 기본키에 비이행적으로 종속할 때(직접 종속) 제 3정규형이라 한다.  이행적 종속?\nA -\u0026gt; B, B -\u0026gt; C 이면 A -\u0026gt; C가 성립되는 함수 종속성   음료주문 릴레이션\n  😈 이상현상  삭제이상: 202번 주문을 취소하면 밀크티 가격에 대한 정보도 사라진다 삽입이상: 신메뉴가 추가되었는데 아직 주문이 없을 시 주문번호를 NULL값으로 삽입해야 하는 문제 수정이상: 밀크티 가격을 5500원으로 변경하면 데이터 불일치가 발생할 가능성  🗝 이상현상 원인 가격이 기본키가 아닌 음료에 함번 더 종속되어 있다. 따라서 (주문번호-\u0026gt;음료), (음료-\u0026gt;가격)로 가격은 기본키에 이행적으로 종속되어 있다.\n🛠 정규형 변환 (주문번호, 음료, 가격) 분해\n-\u0026gt; 주문(주문번호, 음료), 메뉴(음료, 가격)\n BCNF Boyce Codd Normal Form\n릴레이션에 존재하는 함수 종속성에서 모든 결정자가 후보키이면 BCNF 정규형이다\nA relation is BCNF if and only if every determinant is a cadidate key.\n함수 종속성 X-\u0026gt;Y가 성립할 때 모든 결정자 X가 후보키이면 BCNF 정규형이라 한다\n😈 이상현상  특강수강 릴레이션\n   삭제이상: 202202 학생이 수강을 취소하면 실험심리 강좌 정보도 사라진다 삽입이상: 백교수가 새로 특강을 개설했는데 아직 수강 신청한 학생이 없어 학생 번호를 NULL값으로 삽입해야 하는 문제 수정이상: 이교수가 특강 이름을 알고리즘에서 알고리즘 중급으로 바꾸면 데이터 불일치가 발생할 수 있다  🗝 이상현상 원인 결정자이면서 후보키가 아닌 속성이 존재하기 때문에 이상현상이 발생한다.\n예시 릴레이션의 기본키는 (학번, 특강)이며 여기서 볼 수 있는 관계는 (학번, 특강)-\u0026gt; 교수, 교수 -\u0026gt; 특강이름이다. 교수는 결정자이지만 부분 릴레이션(교수, 특강)의 기본키일 뿐 해당 릴레이션의 후보키가 아니다.\n🛠 정규형 변환 특강수강(학번, 특강, 교수)\n-\u0026gt; 특강신청(학번, 교수), 특강교수(특강, 교수)\n 🚨 무손실 분해: 릴레이션을 분해할 때 지켜야 할 규칙 분해된 릴레이션 간의 관계를 유지하기 위해 분해된 릴레이션에 공통 속성을 한 개 이상 두어야 한다.\n릴레이션 R을 릴레이션을 R1, R2로 분해했을 때, 다시 조인 하면 원래의 릴레이션 R이 만들어져야 한다.\n 특강수강(학번, 특강, 교수) -\u0026gt; R1(학번, 교수), R2(특강, 교수)\nR1, R2의 공통 속성은 교수, 교수는 R2의 키이다. -\u0026gt; 무손실 분해 규칙 🅾️ 특강수강(학번, 특강, 교수) -\u0026gt; R1(학번, 특강), R2(교수, 특강)\nR1, R2의 공통 속성은 특강, (분반이 있을 수 있다면..)특강은 R2의 키가 아니다. -\u0026gt; 무손실 분해 규칙 ❌  ","description":"릴레이션을 분해하여 이상현상을 제거하는 정규화","id":10,"section":"posts","tags":["데이터베이스","CS"],"title":"데이터베이스 정규화","uri":"https://www.bemore.dev/posts/cs/database/normalization/"},{"content":"이상현상 Anomaly 💡 잘못 설계된 테이블로 데이터 조작(삽입, 삭제, 수정)을 하면 일어난다.\n 수강정보 테이블에 학생, 학과, 강좌 정보를 한꺼번에 쓴 테이블\u0026hellip;\n  😈 삭제이상 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상\n  예시   학과, 강의 정보 릴레이션이 따로 없다면 Jake의 수강정보를 지웠는데 불문과 정보와 작문강좌에 대한 정보 모두 없어진다.  \n😈 삽입이상 튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL값을 입력해야하는 현상\n  예시   강의를 듣고있는 학생수를 알아내기 위해 count를 할 시 강좌정보가 NULL인 튜플도 포함되어버린다.  \n😈 수정이상 튜플 수정 시 조건을 잘못 주어서 중복된 데이터의 일부만 수정되어 데이터의 불일치 문제가 일어나는 현상\n  예시   \u0026ldquo;데이터베이스\u0026rdquo; 강의실에 대한 정보가 한 학생의 튜플만 업데이트 된다면\u0026hellip; 데이터 불일치 문제가 일어난다.  \n함수 종속성 어떤 속성A의 값을 알면 다른 속성 B의 값이 유일하게 정해지는 의존 관계\nA→B: A는 B의 결정자.\n⚠️ 결정자는 단일 속성일 수도, 복합 속성일 수도 있다!\n표현) x → y : y는 x의 함수 = y는 x에 함수적으로 종속 = y는 x의 종속 속성 = x는 y의 결정자\n 학생수강성적 릴레이션\n  학번 -\u0026gt; 학생이름\n학번 -\u0026gt; 주소\n학번 -\u0026gt; 학과\n학과 -\u0026gt; 학과실\n강좌이름 -\u0026gt; 강의실\n(학번, 강좌이름) -\u0026gt; 학점\n함수 종속성 다이어그램  학생수강성적 릴레이션의 함수 종속성 다이어그램\n  함수 종속성 규칙  부분집합 규칙: if $Y \\subseteq X$, then X → Y 증가 규칙: If X → Y, then XZ → YZ 이행 규칙: If X → Y and Y → Z, then X → Z 결합 규칙: If X → Y and X → Z, then X → YZ 분해 규칙: If X → YZ, then X → Y and X → Z 유사이행 규칙: If X → Y and WY → Z, then WX → Z    예시   부분집합 규칙: (학과, 주소) -\u0026gt; 학과 증가 규칙: (학번, 강좌이름) -\u0026gt; (학생이름, 강좌이름) 이행 규칙: 학번 -\u0026gt; 학과실 결합 규칙: 학번 -\u0026gt; (학생이름, 주소), 학번 -\u0026gt; (학생이름, 주소, 학과) 분해 규칙: 학번 -\u0026gt; 학생이름, 학번 -\u0026gt; 주소 유사이행 규칙: (강좌이름, 학번) -\u0026gt; 성적    $\\therefore$ 정리 ✅ 이상현상은 한 개의 릴레이션에 두 개 이상의 정보가 포함되어 있을 때 나타난다.\n✅ 기본키는 릴레이션의 모든 속성에 대해 결정자다. 이상현상은 기본키가 아니면서 결정자인 속성이 있을 때 발생한다.\n이상현상을 해결하는 방법 👉 정규화\n","description":"삭제이상, 삽입이상, 수정이상, 함수 종속성","id":11,"section":"posts","tags":["데이터베이스","CS"],"title":"데이터베이스 이상현상","uri":"https://www.bemore.dev/posts/cs/database/database3/"},{"content":"Floyd Warshall 그래프의 모든 노드 쌍에 대한 최단거리를 구하는 알고리즘\n모든 지점끼리의 거리를 구한다. 다이니믹 프로그래밍 기반이다. A-\u0026gt;B로 다이렉트로 가는 경로와 A-\u0026gt;k-\u0026gt;B 경유해서 가는 경로를 비교해서 더 비용이 작은 경로의 값으로 갱신한다.\n 시간복잡도: $O(V^3)$  구현 1 2 3 4 5 6 7  INF = int(1e9) def floyd(graph, n): for k in range(1, n+1): for i in range(1, n+1): for j in range(1, n+1): graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])     입력 및 실행 코드  1 2 3 4 5 6 7 8 9 10 11 12 13  n, m = map(int, input().split()) # 노드, 간선 개수 graph = [[INF] * (n+1) for _ in range(n+1)] for a in range(1, n+1): graph[a][a] = 0 # 자기 자신노드에 대한 비용은 0으로 초기화 # 간선 정보 for _ in range(m): source, dest, cost = map(int, f.readline().split()) graph[source][dest] = cost floyd(graph, n) print(graph)      🤔 다익스트라와 비교  다익스트라를 모든 정점에서 돌려도 되지 않나?!\n ✅ 경우에 따라서 다르다.\n간선이 많지 않은 경우(sparse graph) 간선의 개수는 노드의 개수와 비슷해 $E \\fallingdotseq V$ 이면 우선순위 큐를 사용하지 않는 다익스트라라면 시간복잡도 $O(V^3)$로 플로이드-와샬과 같은 시간복잡도이지만 플로이드-와샬보다 구현 난이도가 더 어려울 수 있다. 이때는 간단한 플로이드를 사용하는 것이 낫다. 하지만 우선순위 큐를 사용한 다익스트라라면 시간복잡도는 $O(VElogV)=\u0026gt;O(V^2logV)$로 플로이드 보다 효율적이다.\n간선이 빽빽한 경우(dense graph) 모든 노드끼리 간선이 존재한다면 $E = \\frac {v(v-1)}2 \\fallingdotseq$ $V^2$로 다익스트라 시간복잡도 $O(VElogV)=\u0026gt;O(V^3logV)$라면 플로이드-와샬보다 효율이 떨어진다.\n🤖 정리  sparse 그래프에서 우선순위 큐를 사용한 다익스트라면 효율적일 수도 있다.\n우선순위 큐를 사용하지 않는 다면 플로이드와 비슷하고 플로이드-워셜이 구현하는데 더 편하다. dense 그래프에서는 플로이드-워셜이 더 효율적이다.  ","description":"최단경로 구히가: Floyd Warshall algorithm","id":12,"section":"posts","tags":["알고리즘","그래프","최단경로"],"title":"플로이드 와샬","uri":"https://www.bemore.dev/posts/cs/algorithm/floyd/"},{"content":"Dijkstra 특정 시작점에서 다른 모든 정점으로 가는 최단 거리를 각각 구해주는 알고리즘\nA도시에서 D도시로 가는 최단 비용(거리, 시간, 돈)을 구하는 문제에 적합한 알고리즘.\n⚠️ 음수 가중치 간선이 있는 그래프에서는 쓸 수 없다.\n    시간복잡도     우선순위 큐⭕️ $O(ElogV)$   우선순위 큐❌ $O(V^2)$    구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import heapq INF = int(1e9) def dijkstra(start): queue = [] heapq.heappush(queue, (0, start)) distance[start] = 0 while queue: dist, node = heapq.heappop(queue) for v, c in graph[node]: cost = dist + c if cost \u0026lt; distance[v]: distance[v] = cost heapq.heappush(queue, (cost, v))     입력 및 실행 코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  n, m = map(int, input().split()) # 노드, 간선 개수 start = int(input()) # 출발 노드 graph = [[] for _ in range(n+1)] distance = [INF] * (n+1) # 간선 정보 for _ in range(m): source, dest, cost = map(int, input().split()) graph[source].append((dest, cost)) dijkstra(start) for i in range(1, n+1): if distance[i] == INF: print(\u0026#34;INF\u0026#34;) else: print(distance[i])      ","description":"최단경로 구히가: Dijkstra algorithm","id":13,"section":"posts","tags":["알고리즘","그래프","최단경로"],"title":"다익스트라 알고리즘","uri":"https://www.bemore.dev/posts/cs/algorithm/dijkstra/"},{"content":"DDL 데이터 정의어 Data Definition Language\n데이터베이스나 테이블 등을 생성, 삭제, 변경을 위한 명령어\n 생성: create table 테이블명; 변경: alter table 테이블명  add 속성 타입; modify 속성 타입 (제약조건); drop column 속성; add primary key 속성;   삭제: drop table 테이블명;  DML 데이터 조작어 Data Manipulation Langauge\n데이터베이스에 저장된 데이터를 처리하거나 조회, 검색하기 위한 명령어. 튜플에 대한 처리\n 조회: select 속성 from 테이블; 삽입: insert into 테이블명 (속성1, 속성2..) values (값1, 값2..); 수정: update 테이블 set 속성1=값1, 속성2=값... where 조건; 삭제: delete from 테이블 where 조건;  DCL 데이터 제어어 Data Control Language\n데이터 사용권한 관리. 데이터베이스에 저장된 데이터를 관리하기 위하여 데이터의 보안성 및 무결성 등을 제어하기 위한 명령어\n grant 권한 on 객체 to 사용자 (with grant option); revoke 권한 on 객체 from 사용자;  ","description":"데이터베이스-2","id":14,"section":"posts","tags":["데이터베이스","CS"],"title":"DML, DCL, DDL","uri":"https://www.bemore.dev/posts/cs/database/database2/"},{"content":"데이터베이스  프로젝트에 필요한 정보를 얻기 위해 논리적으로 연관된 데이터를 모아 구조적으로 통합해 놓은 것 - 데이터베이스 개론\n 개념  integrated data: 중복을 최소화함으로써 데이터 불일치 현상을 없앤다 stored data: 컴퓨터 저장장치에 저장된 데이터 operationl data: 프로젝트의 목적을 위해 사용되는 데이터 shared data: 여러 사람이 동시에 사용할 수 있다  특징   real time accessibility: 사용자가 요청하는 순간에 실제 데이터를 서비스\n  continuous change: 삽입, 삭제, 수정등으로 바뀐 데이터값 저장\n  concurrent sharing: 동시에 여러 사용자가 데이터 요청가능\n  reference by content\n  데이터 구조  외부 단계- 외부 스키마: 개념 스키마 중 사용자에게 필요한 부분 개념 단계- 개념 스키마: 전체 데이터베이스의 정의. 통합 조직별로 하나만 존재.  데이터 관계, 제약사항, 무결성   내부 단계- 내부 스키마: 물리적 저장 장치에서 데이터베이스가 실제로 저장되는 방법의 표현.  인덱스, 데이터 레코드의 배치 방법, 데이터 압축\u0026hellip;    💡 스키마: 데이터베이스의 조직이나 구조 데이터 모델 SQL 실습 사이트\n데이터 무결성 데이터베이스에 저장된 데이터의 일관성과 정확성을 지키는 것.\n무결성 제약조건  도메인 무결성 제약조건 개체 무결성 제약 조건(=기본키 제약)  NULL ❌ 키값 변동 ❌ 최소 집합. 최대한 적은 수의 속성만 가짐 문제 발생 소지 ❌   참조 무결성 제약 조건(=외래키 제약)  key 🔑 튜플을 유일하게 식별하는 장치, 각 릴레이션 간의 관계 말해주는 연결고리  슈퍼키 superkey: tuple 유일하게 식별할 수 있는 속성 or 속성집합 후보키 candidate key: 튜플 유일하게 식별할 수 있는 최소집합 기본키 primary key: 후보키 중 하나 선정하여 대표로 삼은 키    대리키 surrogate key: 마땅한 키 없을 때 가상 속성 만들어 기본키로.\n  대체키 alternate key: 기본키로 선정되지 않은 후보키\n  외래키 foreign key: 다른 테이블 기본키를 참조하는 속성. 테이블 간 관계 표현\n  ","description":"데이터베이스-1","id":15,"section":"posts","tags":["데이터베이스","CS"],"title":"데이터베이스 개념, 데이터 무결성","uri":"https://www.bemore.dev/posts/cs/database/database1/"},{"content":"이진 탐색  타겟이 중간값보다 크면 왼쪽 버리고 오른쪽만 보면 됨🔎 타겟이 중간값보다 작으면 오른쪽 버리고 왼쪽만 보면 됨🔍     1 2 3 4 5 6 7 8 9 10 11 12 13 14  def binarySearch(arr, target): left = 0 right = len(arr) - 1 while left \u0026lt;= right: mid = (left + right) // 2 if arr[mid] == target: return mid if arr[mid] \u0026gt; target: right = mid - 1 else: left = mid + 1 return -1   이진탐색은 기본적으로 정렬된 상태여야 합니다. 반복할수록 탐색할 범위가 절반으로 줄어들게 됨으로 시간복잡도는 O(logN)입니다.\ntarget의 \u0026ldquo;개수\u0026rdquo; 구하기 🧦 upper bound - lower bound = target의 개수 Upper Bound target 초과인 값이 최초로 나오는 위치\n1 2 3 4 5 6 7 8 9 10 11 12 13  def upperBound(arr, target): left = 0 right = len(arr) - 1 min_idx = len(arr) while left \u0026lt;= right: mid = (left + right) // 2 if arr[mid] \u0026gt; target: right = mid - 1 min_idx = mid else: left = mid + 1 return min_idx   Lower Bound target 이상인 값이 최초로 나오는 위치\n1 2 3 4 5 6 7 8 9 10 11 12 13  def lowerBound(arr, target): left = 0 right = len(arr) - 1 min_idx = len(arr) while left \u0026lt;= right: mid = (left + right) // 2 if arr[mid] \u0026gt;= target: right = mid - 1 min_idx = mid else: left = mid + 1 return min_idx   ","description":"binary search, lower bound, upper bound","id":16,"section":"posts","tags":["알고리즘","탐색"],"title":"BinarySearch","uri":"https://www.bemore.dev/posts/cs/algorithm/binarysearch/"},{"content":"Merge Sort     구현 코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  def merge_sort(arr, left, right): if left \u0026lt; right: mid = (left + right) // 2 merge_sort(arr, left, mid) merge_sort(arr, mid+1, right) merge(arr, left, mid, right) def merge(arr, left, mid, right): i = left j = mid + 1 merged_arr = [0] * (right+1) k = left while i \u0026lt;= mid and j \u0026lt;= right: if arr[i] \u0026lt;= arr[j]: merged_arr[k] = arr[i] k += 1 i += 1 else: merged_arr[k] = arr[j] k += 1 j += 1 while i \u0026lt;= mid: merged_arr[k] = arr[i] k += 1 i += 1 while j \u0026lt;= right: merged_arr[k] = arr[j] k += 1 j += 1 for k in range(left, right+1): arr[k] = merged_arr[k] return arr      Quick Sort     구현 코드  다른 자료의 psuedo코드 기반으로 설명 영상의 s, e 동작과는 다르게 구현되었습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  def quick_sort(arr, left, right): if left \u0026lt; right: pos = partition(arr, left, right) quick_sort(arr, left, pos - 1) quick_sort(arr, pos + 1, right) def partition(arr, left, right): pivot = arr[right] # 가장 오른쪽 원소를 pivot으로 잡는 경우 s = left - 1 # s는 pivot보다 작은 수를 가리킨다 for e in range(left, right): # e는 pivot보다 같거나 큰 수를 가리키는데 if arr[e] \u0026lt; pivot: # 그렇지 않으면  s += 1 arr[s], arr[e] = arr[e], arr[s] # swap arr[s+1], arr[right] = arr[right], arr[s+1] # pivot 변경 return i + 1 # pivot 최종 위치 반환      Heap Sort     구현 코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  def heap_sort(arr, n): for i in range(n//2, 0, -1): build_heap(arr, n, i) for i in range(n, 1, -1): arr[1], arr[i] = arr[i], arr[1] build_heap(arr, i, 1) # heapify method (max-heap) def build_heap(arr, n, i): largest = i l = i * 2 # 왼쪽 자식 노드 인덱스 r = i * 2 + 1 # 오른쪽 자식 노드 인덱스 if l \u0026lt; n and arr[l] \u0026gt; arr[largest]: largest = l if r \u0026lt; n and arr[r] \u0026gt; arr[largest]: largest = r if largest != i: arr[i], arr[largest] = arr[largest], arr[i] build_heap(arr, n, largest) # 힙의 부모-자식 인덱스 관계를 위해서 1번 인덱스부터 루트노드가 들어간다 arr = [-, 6, 1, 4, 8, 3, 9, 2, 5] heap_sort(arr, 8) print(arr)      ","description":"O(NlogN) 시간 복잡도를 갖는 병합 정렬, 퀵 정렬, 힙 정렬","id":17,"section":"posts","tags":["알고리즘","정렬"],"title":"정렬-2","uri":"https://www.bemore.dev/posts/cs/algorithm/sort2/"},{"content":"Bubble Sort      구현 코드  1 2 3 4 5 6 7 8  def bubble_sort(arr): n = len(arr) for i in range(n-1): for j in range(n-1-i): if arr[j] \u0026gt; arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr     \nSelection Sort      구현 코드  1 2 3 4 5 6 7 8 9 10  def selection_sort(arr): n = len(arr) for i in range(n-1): min = i # i번째로 작은 원소의 인덱스 일단 i로 초기화 for j in range(i+1, n): if arr[min] \u0026gt; arr[j]: min = j arr[i], arr[min] = arr[min], arr[i] return arr     \nInsert Sort      구현 코드  1 2 3 4 5 6 7 8 9 10 11 12 13  def insert_sort(arr): n = len(arr) for i in range(n): j = i - 1 key = arr[i] while j \u0026gt;= 0 and arr[j] \u0026gt; key: arr[j+1] = arr[j] # j를 오른쪽으로 한 칸 밀어줌 j -= 1 arr[j+1] = key return arr     \nRadix Sort   구현 코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def radix_sort(arr, k): for pos in range(k): # 10**pos 자리수 arr_new = [[] for _ in range(10)] for i in range(len(arr)): digit = pos_digit(arr[i], pos) arr_new[digit].append(arr[i]) store_arr = [] for i in range(10): for j in range(len(arr_new[i])): store_arr.append(arr_new[i][j]) arr = store_arr return arr # 자리수 구하기 def pos_digit(number, pos): return (number % (10 ** (pos+1))) // (10 ** pos)      ","description":"O(N^2) 시간 복잡도를 갖는 버블 정렬, 선택 정렬, 삽입 정렬, O(k*N)의 기수정렬","id":18,"section":"posts","tags":["알고리즘","정렬"],"title":"정렬-1","uri":"https://www.bemore.dev/posts/cs/algorithm/sort1/"},{"content":"🎄 특별한 이진 트리\n완전 이진 트리에서 부모 노드가 자식 노드 값보다 같거나 작은(MinHeap)/큰(MaxHeap) 경우를 만족한다. 현재 남아있는 원소들 중 최대값 or 최솟값을 빠르게 계속 얻고 싶은 경우에 유용  heap만드는 데 O(NlogN) 소요 이후 삽입, 삭제 O(logN) 최소값 or 최대값 탐색 O(1)  구현   heapify      insert      remove    ","description":"","id":19,"section":"posts","tags":["자료구조","힙"],"title":"Heap","uri":"https://www.bemore.dev/posts/cs/datastructure/heap/"},{"content":"휴고 블로그를 처음 만들었을때 나름 많이 찾아보고 고른 테마였는데도 뭔가 아쉬운 점이 많았다. 그래도 레이아웃도 커스텀하고 쓰고 있었는데 더 좋아보이는 테마를 발견해서 바꾸고 싶었다. 변경해야하는 파일이 많을까 걱정했지만 관련 블로그글을 따라해보니 생각보다 간단했다!\n0. content파일 백업 작성한 글들이 있는 content폴더를 다른 곳에 복사해두고 3번 단계를 진행할때 변경된 구조에 필요한 부분을 복붙하는게 더 편할 수 있다. 물론 혹시 모르니 백업하는 건 중요하다\u0026hellip;\n1. 기존 테마 삭제 연결되어 있던 서브모듈 끊기\n git submodule deinit -f 기존테마 rm -rf .git/modules/기존테마 git rm -f 기존테마  2. 새로운 테마 받기 새로운 서브모듈 연결\ngit submodule add 새테마git저장소 themes/새테마\n3. 파일구조 맞추기 themes/테마/exampleSite의 파일구조를 참고하거나 복붙해서 기존의 작성한 글들을 알맞은 폴더로 이동시킨다. 테마에서 요구하는 기본 폴더들의 구조와 폴더명을 유지해야한다. 이후에 필수요소가 아니라면 자신이 원하는 블로그 형태에 맞게 삭제, 수정한다.\n 설정파일 수정하기\n기존 테마는 toml파일 대신 yaml 설정 파일을 썼기 때문에 기존의 설정파일을 삭제한다. 보통 themes/테마/exampleSite에 있는 설정파일(config.toml)을 내 블로그 폴더 root 위치에 복사한다음 내 정보에 맞게 설정을 수정한다. 이번 테마는 설정파일들이 모두 config폴더 내에 있어서 config폴더 자체를 root 위치에 복붙해서 썼다.  4. 로컬 서버에서 변경사항 확인하기 hugo server로 문제 없는지 확인\n5. 블로그 저장소(blog, github.io) 업데이트 기존과 같지만 hugo -t부분을 새로운 테마명으로 하는 것을 주의한다. 원본저장소, public저장소에 올려서 변경사항을 반영한다.\ncd blog hugo -t 테마 cd public git add . git commit -m \u0026quot;커밋 메시지\u0026quot; git push orgin main (내계정.github.io의 메인브랜치명 main이었다) cd .. git add . git commit -m \u0026quot;커밋 메시지\u0026quot; git push origin master (블로그 저장소 메인브랜치명은 master..) 🍀 참고 블로그  Git Submodule 삭제 방법 How to switch to another Hugo theme (Hugo 테마 변경하기)  ","description":"쓰고 싶은 테마가 생겼을때, 바꾸는 방법. 어때요, 참 쉽죠?","id":20,"section":"posts","tags":["hugo","blog"],"title":"hugo 블로그 테마 바꾸기","uri":"https://www.bemore.dev/posts/devstory/chage_theme/"},{"content":"트리 🌲 정점끼리 전부 연결되어 있으면서 사이클이 존재하지 않는 그래프\n 원소의 구성을 정말 나무처럼 표현한 예시로 영화 \u0026lsquo;해리포터\u0026rsquo; 속에서 나왔던 시리우스 블랙의 가계도가 생각났다. 자료구조의 트리는 나무가 거꾸로 있는 형태이므로 가문의 선조가 가장 위에 있도록 원본 이미지를 회전했다.\n  ⬆️위와 같은 가계도 모양을 생각하면 노드는 가문의 각 구성원이며 왜 상위 노드를 부모 노드, 하위 노드가 자식 노드라고 불리는지 쉽게 이해할 수 있다. 이 예시로 트리 용어들을 일상적으로 비유해 본다면 루트 노드는 가문의 선조, 차수는 각 구성원에서 뻗어나간 가지 수로 몇 명의 자식이 있는지, 깊이는 현재 구성원이 선조로부터 몇 세대 내려왔는지, 높이는 마지막 후손의 깊이이다.\n이진 트리 🌲 자식 수가 최대 2개인 트리 이진트리 탐색  전위 탐색: 부모 - 좌 - 우 중위 탐색: 좌 - 부모 - 우 후위 탐색: 좌 - 우 - 부모  이진탐색트리  왼쪽 방향에 있는 노드들은 전부 부모 보다 값이 작아야 함 우측 방향에 있는 노드들은 전부 부모 보다 값이 커야만 한다 삽입 삭제  균형잡힌 이진 탐색 트리 삽입, 삭제가 일어나는 순간 루트 노드와 주위에 있는 노드를 회전 등의 작업을 통해 적절하게 조절 → 트리의 높이를 최소화  트리 높이를 항상 logN으로 유지할 수 있다 삽입, 삭제, 탐색 시간 O(logN)  완전 이진 트리  모든 값이 왼쪽에서 순서대로 차 있다 모든 노드에 대해 부모 노드가 자신의 자식보다 같거나 큰 or 작은 경우 👉 Heap  ","description":"","id":21,"section":"posts","tags":["자료구조","트리"],"title":"Tree","uri":"https://www.bemore.dev/posts/cs/datastructure/tree/"},{"content":"공식문서\n누구나 쉽게 이해할 수 있는 Git 입문\ngit 개념 버전 관리? 파일의 변화를 시간에 따라 기록했다가 필요한 경우 특정 시점의 버전을 다시 꺼내올 수 있는 시스템\n 중앙집중식 버전 관리(CVCS)  중앙 서버에 문제가 생기면 협업 불가   분산 버전 관리 시스템(DVCS)  로컬 저장소가 원격 저장소의 파일, 히스토리 모두 복제 -\u0026gt; 백업 유리    git 기본 Repository: local - remote   원격 저장소 연결\n git clone \u0026lt;원격서버주소\u0026gt; :원격 저장소 받아오기 git remote add origin 원격저장소주소    upstream 저장소 설정\n git remote add upstream 저장소 : 포크한 저장소의 원본 저장소 연결 git remote set-url **upstream** \u0026lt;오픈소스 저장소 주소\u0026gt;    원격 저장소 확인\n git remote -v : 원격 저장소 위치 확인    원격 저장소 연결 삭제\n git remote remove origin : 원격 저장소 연결 끊기    원격 저장소 수정\n git remote set-url **origin** \u0026lt;변경할 원격서버 주소\u0026gt; : 저장소 변경 git remote update → 원격 브랜치 갱신된다 → 수정 후 commit → 코맨트 남기고 → 확인 → 머지    메인 브랜치를 master가 아닌 main으로 설정하기\ngit branch -M main\n  Update  upstream 저장소의 변경사항 받아오기  git fetch upstream git merge upstream/master git push origin master : 로컬에서 원본 저장소의 내용으로 업데이트하고 이를 원격 저장소에 반영    Commit  커밋 상태 조회  git log --oneline git log --branches --not --remotes : ✅push하지 않은 커밋 확인✅   원격에 이미 올라간 커밋을 바꾸고 싶다면  커밋 취소하기: git reset --soft HEAD^ 커밋 되돌리기: git revert HEAD^ -\u0026gt; 커밋을 되돌린 것이 기록됨  HEAD^: 바로 이전 커밋 HEAD~n: n번째 전 커밋 (HEAD~1==HEAD^)   커밋 덮어쓰기: git commit --amend    Branch   생성git branch 브랜치이름\n  이동\n git checkout 브랜치 git checkout -b 브랜치 : 브랜치 생성과 이동    확인 git branch\n  삭제\nmain 브랜치로 이동 후\n git branch -D 브랜치 git push origin --delete 원격브랜치 : 원격 브랜치 삭제    브랜치 합치기\n  머지\ngit merge 합칠브랜치\n  Git Flow A successful Git branching model\n번역\ngitflow 구현 저장소\n우아한 형제들의 적용 사례\n","description":"프로젝트 관리, 오픈소스를 위한 간단한 깃 활용 연습하기! 버전 업데이트, 커밋, 브랜치까지","id":22,"section":"posts","tags":["git","오픈소스"],"title":"Git 기본 활용","uri":"https://www.bemore.dev/posts/devstory/about_git0/"},{"content":"연결 리스트 연결된 데이터를 저장할때 사용합니다.\n연결리스트를 구성하는 노드의 구조는 다음과 같습니다.\n node  data link(next)    \n   장점 단점     삭제와 삽입 O(1)길이가 정해지지 않은 데이터를 다룰때 유용 메모리 요구량이 더 크다 원하는 위치 검색할 때 처음부터 다 확인해야한다    배열과 비교     배열 연결리스트     삽입/삭제 O(n) O(1)   저장공간 연속한 위치 임의의 위치   탐색 O(1) O(n)    단순 연결 리스트 구현 노드\n1 2 3 4  class Node: def __init__(self, item): self.data = item self.next = None   연결 리스트\n1 2 3 4 5  class LinkedList: def __init__(self): self.nodeCount = 0 # 노드의 개수 self.head = None # 처음 노드 self.tail = None # 끝 노드     탐색: k번째 원소 찾기  1 2 3 4 5 6 7 8 9  def getAt(self, pos): if pos \u0026lt; 1 or pos \u0026gt; self.nodeCount: # 범위 벗어났다면 return None i = 1 curr = self.head # 맨 앞 노드부터 while i \u0026lt; pos: curr = curr.next i += 1 return curr        리스트 순회  1 2 3 4 5 6 7  def traverse(self): answer = [] curr = self.head while curr is not None: answer.append(curr.data) curr = curr.next return answer        길이 알아내기  1 2  def __len__(self): return self.nodeCount        원소 삽입  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  def insertAt(self, pos, newNode): if pos \u0026lt; 1 or pos \u0026gt; self.nodeCount + 1: # 범위 밖 인덱스라면 return False if pos == 1: # 맨 앞에 삽입 newNode.next = self.head self.head = newNode else: if pos == self.nodeCount + 1: # 맨 뒤에 삽입 prev = self.tail else: prev = self.getAt(pos - 1) # 중간에 삽입 newNode.next = prev.next prev.next = newNode if pos == self.nodeCount + 1: self.tail = newNode self.nodeCount += 1 return True        원소 삭제  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  def popAt(self, pos): if pos \u0026lt;= 0 or pos \u0026gt; self.nodeCount: raise IndexError if self.nodeCount == 1: # 노드가 하나밖에 없는 연결리스트 curr = self.getAt(pos) self.head = None self.tail = None self.nodeCount -= 1 return curr.data # 삭제하려는 노드가 맨 앞이면 -\u0026gt; prev 없음. Head 조정 if pos == 1: curr = self.head self.head = curr.next # 리스트 맨 끝 노드 삭제할때 -\u0026gt; Tail 조정 필요 elif pos == self.nodeCount: curr = self.tail prev = self.getAt(pos - 1) prev.next = None self.tail = prev else: prev = self.getAt(pos - 1) curr = prev.next prev.next = curr.next self.nodeCount -= 1 return curr.data        두 리스트 합치기  1 2 3 4 5  def concat(self, L): self.tail.next = L.head if L.tail: self.tail = L.tail self.nodeCount += L.nodeCount      원형 연결 리스트 이중 연결 리스트 참고자료 🖥 연결리스트 연산 PPT\n자료구조09 - 연결리스트(Linked List)2\nhttps://wayhome25.github.io/cs/2017/04/17/cs-19/\nhttps://opentutorials.org/module/1335/8821\n","description":"","id":23,"section":"posts","tags":["자료구조","연결리스트"],"title":"Linked List","uri":"https://www.bemore.dev/posts/cs/datastructure/linkedlist/"},{"content":"요즘 번역 오픈소스 프로젝트를 하다보니 커밋하고 나서 보이는 오타들이 있었다. 하지만 글자 하나 때문에 새로 커밋 올리는 것은 깔끔하지 않다고 생각되고 어떤 오픈소스 프로젝트에서는 불필요한 커밋은 합쳐서 올리기를 요청하기도 한다고 했다(기본인가..?)🤔\n이럴땐 커밋 취소, 되돌리기, 덮어쓰기를 상황에 맞게 사용하자.\ngit log --oneline\n현재 커밋 로그를 조회해서 어느 지점 커밋으로 되돌리고 싶은지 확인한다.\n8d9111b (HEAD -\u0026gt; ddp_pipeline, origin/ddp_pipeline) 커밋4 cedfd58 커밋3 f0780f0 커밋2 b908557 커밋1 ✅ 이미 올라간 커밋을 바꾸고 싶다! 어떻게?\n  방법1 커밋 취소하기:git reset --soft HEAD^\n로컬 저장소 상태를 커밋 이전 상태로 강제 변경해린다.\n⚠️ 해당 브랜치를 협업하고 있다면 위험할 수 있다⚠️\n --soft: 지정한 커밋에 있던 내용이 stage에 있는 상태로 되돌려진다. --hard: 지정한 커밋 기점의 상태로 되돌아간 상태이다. HEAD^: 바로 이전 커밋으로 돌아가기 HEAD~n: n전 커밋으로 돌아가기 (HEAD~1==HEAD^)    방법2 커밋 되돌리기:git revert HEAD^\n커밋을 되돌렸다는 게 히스토리에 남는다.\n  방법3 커밋 덮어쓰기: git commit --amend\n추가 작업을 이전 커밋에 포함시킨다. (이게 제일 좋은 방법같다..)\n하지만 이미 원격 저장소에 push한 커밋 내용이라면 resest처럼 force push 필요하다)\n  나는 해당 브랜치를 함께 작업하는 사람이 없어서 reset을 사용하는데 문제가 없었고 이전 커밋을 취소하고 새 커밋을 올리리고 싶었다. 이 방법으로 오타까지 고친 커밋5를 새로 올리고 히스토리에 커밋4를 남기지 않는다.\n git reset --soft HEAD^  cedfd58 (HEAD -\u0026gt; ddp_pipeline) 커밋3 f0780f0 커밋2 b908557 커밋3 기존의 수정한 내용을 지우지 않고 한군데만 더 고치면 되어서 hard 대신 soft 옵션을 줬다.\n스테이지에 추가되어있던 파일을 내려주고 수정하기 git commit -m \u0026quot;message\u0026quot; 커밋 올리기 git push -f origin ddp_pipeline  cfb8eec (HEAD -\u0026gt; ddp_pipeline, origin/ddp_pipeline) 커밋5 cedfd58 커밋3 f0780f0 커밋2 b908557 커밋3 다음엔 revert를 사용해야겠다.\n","description":"","id":24,"section":"posts","tags":["git","오픈소스"],"title":"리모트에 올린 커밋 취소 or 되돌리기","uri":"https://www.bemore.dev/posts/devstory/about_git/"},{"content":"😷 올해도 코로나 올해도 코로나는 끝나지 않았다\u0026hellip; 이제는 \u0026lsquo;곧 끝나겠지\u0026rsquo;라는 생각도 들지 않지만 \u0026lsquo;언젠간 끝나겠지\u0026rsquo;라는 마음이다. 언젠가 끝날 때까지 모두 건강하길!\n🖥 Mac mini M1 사용기 10년 동안 쓴 데스크탑을 보내주고 MacOS를 체험해 보고 싶어서 Mac mini M1을 선택했다. 일단 맥북보다 가격이 낮았고(옵션을 추가했더니 원래 가격보다 더 올라갔지만) 발열, 소음이 거의 없었다. 1년 동안 사용하면서 성능도 만족한다. 다만 아직 개발 생태계에서 지원해 주지 않는 곳이 아직 있을 수 있다. 가끔 개발환경 세팅하거나 이전에 썼던 툴이 설치가 안 되거나 실행이 안 된다면 \u0026lsquo;이걸 M1이 또..?\u0026lsquo;라고 생각된다. 하지만 애플이 앞으로 M1 Pro, M2 등 자체 개발 칩을 개발하기 때문에 앞으로는 표준이 될 것으로 기대된다.\n🌱 오픈소스 프로젝트: 파이토치 한국어 튜토리얼 파이토치를 처음 공부할 때 당연히 참고하는 파이토치 튜토리얼 공식 문서는 한글 지원이 없어서 공부할 때 더 어렵게 느껴졌다. 그런 나에게 파이토치 한국어 튜토리얼은 한줄기 빛이었다. 마침 8월쯤 2021 오픈소스 컨트리뷰션 아카데미 신청 기간이 있었다. 해당 프로젝트도 멘티를 모집하는 것을 확인하고 이 기회에 튜토리얼 사이트를 사용하면서 찾았던 불편한 점을 개선해 보고 싶어서 참가하게 되었다. 주로 다른 컨트리뷰터가 올린 번역 PR에 대한 리뷰하기, 문서 번역, 머신러닝 용어에 대한 번역 용어 고정에 대해 기여할 수 있었다. 다들 번역 잘하셔서 PR을 리뷰하기 위해서는 여러 번 봐야지 작은 부분이라도 찾을 수 있었고 리뷰하면서도 혹시 틀린 내용이 있을까 더 찾아보고 코멘트를 남겼다. 그래서 간단한 내용이어도 어떤 식으로 의견을 전달하면 좋을지 계속 쓰고 지웠다 반복했던 것 같다. 번역만 생각했는데 오픈소스 프로젝트를 어떻게 더 잘 운영할 수 있는지, CI/CD, 번역 편의와 일관성, 사용자들에게 정보를 더 쉽게 표현할 수 있을지 등등\u0026hellip; 많은 부분 생각해보는 시간이었다. 오픈소스 프로젝트에 참여하는 기본 방법(컨트리뷰션 가이드, 번역규칙 등)부터 차근차근 해당 프로젝트 메인테이너인 멘토님이 알려주시고 멘티들과 함께 할 수 있어서 많이 배우고 재밌게 참여할 수 있었다. 무엇보다도 내가 작업한 내용이 많은 사람들이 사용하는 오픈소스에 반영된다는 점이 정말 신기하고 신난다..!\n🌿 블로그 노션, 벨로그로 개발 블로그 쓰고 있었다. 노션엔 주로 공부한 내용을 정리하고 벨로그에는 정보를 공유하는 용도로 사용하였다. 개발 정보를 찾을 때 볼 수 있었던 github.io주소의 블로그들을 볼 때마다 나도 원하는 기능을 넣은 블로그를 직접 만들고 싶었다. 마침 21년 회고를 작성하면서 이를 실을 블로그를 장만하고 싶다는 동기가 생기자 당장 시작했다. 정적 사이트 생성기 Hugo를 활용한 블로그 글들을 참고해서 블로그를 만들었다. 쇼핑하는 것처럼 여러 템플릿 찾아보고 더 좋아보이는 템플릿이 보일때마다 장바구니같이 기록하게 되는 재미가 있다. 최대한 지금 테마에 원하는 기능이 들어가도록 조금씩 계속 뜯어 고치고 있다. 당장 내가 쓰고 싶어서 작업하는 과정이 즐겁다. 그 과정에서 다양한 블로그들을 볼 수 있었고 기록의 중요성을 확인하는 시간이었다. 그 기록들 덕분에 나만의 공간을 마련할 수 있었다. 당장은 내가 하고 싶은 일을 하면서 찾았던 정보들을 정리한 수준밖에 되지 않지만 꾸준히 정리하고 공유하면서 내가 얻었던 도움의 조각만큼이라도 다른 사람들에게도 도움을 줄 수 있는 글을 쓰고 싶다. 또한 개발이 아닌 다양한 분야에 대한 공부와 생각도 정리할 수 있는 공간으로 꾸며나갈 예정이다.\n📚 매달 책 1권 독서 작년부터 한 달에 한 번 주제를 정해 책 1권 읽는 모임에 있었는데 아쉽게도 모임이 끝나게 되었다. 메모장 앱에 쓰다가 독서 기록 앱을 발견해서 그동안 읽었던 책을 정리하고 읽고 있는 책을 더 효과적으로 기록할 수 있었다. 주로 고전 소설만 읽었는데 다른 분야도 균형 있게 읽어야겠다는 필요성을 느껴서 인문학 도서를 읽는 북클럽에 참여했다. 읽고 싶었는데 미루던 책을 읽는 시간을 가졌다. 각 장에 대한 생각을 정리하고 에세이를 작성하면서 오랜만에 글쓰기를 한 느낌이다. 내년엔 더 많이 읽을 필요가 있다\u0026hellip;\n느낀점 공부는 끝이 없다. 배우고 싶었던 분야를 새로 공부면서 더닝 크루거 효과처럼 우매함의 봉우리와 절망의 계곡에 있었던 것 같다. 이제는 좀 절망의 계곡에서 나와서 비탈길 입구라도 밟았을까? 그냥 멈추지 않고 계속해야겠다.\n교육 프로그램에서 머신러닝 기초를 배우고 팀 프로젝트가 있었다. 원래는 2달간 대면으로 만나면서 진행할 수 있을 줄 알았는데 7월부터 코로나 추세가 심해져 프로젝트 동안 2번 만나고 모두 화상으로 진행되었다. 대면으로 못 만나면 팀원간 소통이나 피드백이 불편하지 않을까 걱정했는데 pr남기고 슬랙, 게더 등 협업 툴을 자주 사용하니 직접 모여서 하는 것보다 편했다. 백엔드로 부족한 점이 많아서 모델 서빙뿐만 아니라 다른 부분도 더 공부해야겠다.\n자소서를 작성하면서 글쓰기는 피할 수 없는 존재라는 걸 뼈저리게 느끼는 중이다. 메모와 단순한 기록에 익숙해서 그것들을 어떻게 풀어 쓸지 막막했다. 다양한 상황에서도 목적에 맞는 글을 쓰는 과정이 필요했고 여태 공부하면서 읽었던 글들이 더 대단하고 소중하게 보였다. 안다고 생각한 내용도 막상 내 언어로 표현하려고 보면 더없이 낯설다. 알고 있다는 착각에서 나와서 말로 설명해 보고 글로 정리할 필요가 있다.\n회고 모임을 통해서 차분하게 올해를 마무리할 수 있었다. 같은 1년의 시간 속에서 다양한 성장을 기록한 멋진 분들을 만나는 시간이었다. 내년에는 더 다양한 활동으로 회고를 채우고 싶다.\n아쉬운 점  코로나 언제 끝나\u0026hellip;  내년에는  기획한 프로젝트 서비스까지 코로나 끝나길  ","description":"회고 모임과 함께한 회고","id":25,"section":"posts","tags":["회고"],"title":"2021년 회고","uri":"https://www.bemore.dev/posts/retrospect/y2021/"},{"content":"로컬에서 되던 검색이 도메인에서는 안된다..? 블로그 만들고 도메인 설정하고 신나게 글을 쓰다가 검색기능이 안되는걸 발견했다. 빌드한 그대로 로컬에서 돌려봤을때는 잘만 되는데..?\n도메인에서는 다음과 같은 에러메시지가 나오는 상태였다.\nbaseURL 설정이 웹에서 요구하는 주소 형태랑 좀 달라서 나타난 문제같았다.\n🛠 해결   config.yaml에서 baseURL을 www.bemore.dev로 바꿔도 달라지지 않았다.\n  CNAME 파일 확인하기\nCNAME 내부 주소 값이 처음 도메인 설정해줄때 www.bemore.dev였는데 빌드하고 나서 bemore.dev로 바꼈던 부분이 생각났다.\n\u0026lt;- Push할 떄마다 페이지가 작동하지 않을수도 있다고 해서 이를 방지하기 위해 static/CNAME을 작성할때\n😈 www를 뺀 apex주소를 썼던거 때문이었다. 😈\n  static/CNAME\n👉 내용 www.도메인주소으로 수정하고 Push\n  🎉 이제 도메인에서도 제대로 작동한다!\n참고 Search works locally but not on domain\n\u0026ldquo;Search\u0026rdquo; still not functioning with CORS blocking\n블로그 그만 고치고 글 쓰겠어\u0026hellip;\n","description":"로컬에서는 되는데 도메인에서는 왜..?","id":26,"section":"posts","tags":["blog","hugo"],"title":"어느날 Hugo 블로그 검색이 안될때","uri":"https://www.bemore.dev/posts/devstory/blogsearch/"},{"content":"이번 장에서는 분류 모델을 구축하면서 딥러닝의 가능성 및 제한사항을 살펴볼 수 있다. 이 곰돌이가 어떤 곰돌이인지 예측하는 모델을 다뤄봅시다 🐻\n데이터 다운로드 책에서는 빙 이미지 검색의 데이터를 사용했지만 빙 이미지 검색은 보안키를 요구해서\u0026hellip;좀 더 편하게 이미지 데이터를 받아올 방법을 찾아보았다.\n역시 fastai공식 자료를 찾아보니 귀찮게 보안키를 요구하지 않는 DuckDuckGo 이미지를 편하게 받아서 쓸 수 있는 방법이 있었다!\n1  !pip install fastbook   1 2 3  from fastbook import * urls = search_images_ddg(\u0026#39;grizzly bear\u0026#39;, max_images=100) len(urls), urls[0]   출력:\n(100, 'https://s3-us-west-2.amazonaws.com/cdn.yellowst.one/animals/grizzly-bear.jpg')  다운로드한 이미지 하나 열어서 확인하면\u0026hellip;\n1 2 3 4  download_url(urls[0], \u0026#39;images/bear.jpg\u0026#39;) im = Image.open(\u0026#39;images/bear.jpg\u0026#39;) im.thumbnail((256,256)) im     /* Turns off some styling */ progress { /* gets rid of default border in Firefox and Opera. */ border: none; /* Needs to be in here for Safari polyfill so background images work as expected. */ background-size: auto; } .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar { background: #F44336; }   100.51% [180224/179315 00:00각 검색어에서 얻은 모든 URL의 이미지를 fastai가 제공하는 download_images 함수로 다운로드 하여 검색어가 이름인 별도의 폴더에 저장한다.\n1 2 3 4 5 6 7 8 9  bear_types = \u0026#39;grizzly\u0026#39;, \u0026#39;black\u0026#39;, \u0026#39;teddy\u0026#39; path = Path(\u0026#39;bears\u0026#39;) if not path.exists(): path.mkdir() for o in bear_types: dest = (path/o) dest.mkdir(exist_ok=True) download_images(dest, urls=search_images_ddg(f\u0026#39;{o}bear\u0026#39;, max_images=150))   1 2  fns = get_image_files(path) fns[:5]   출력:\n(#5) [Path('bears/teddy/00000085.png'),Path('bears/teddy/00000008.jpg'),Path('bears/teddy/00000107.jpg'),Path('bears/teddy/00000168.jpeg'),Path('bears/teddy/00000130.jpg')]  가끔 파일에 오류가 발생할 수 있어서 verify_images 함수로 검사\n1 2  failed = verify_images(fns) failed   출력:\n(#1) [Path('bears/teddy/00000101.png')]  map 메서드는 호출 시 인자로 전달된 함수를 컬렉션에 포함된 각 요소에 적용.\nunlink 함수를 사용해 오류가 발생한 모든 요소 삭제.\n1  failed.map(Path.unlink)   (#1) [None]  데이터에서 DataLoaders까지 다운로드한 데이터를 DataLoaders객체로 만들어 목적에 맞게 학습용과 검증용으로 나눈다.\n1 2 3 4  class DataLoaders(GetAttr): def __init__(self, *loaders): self.loaders = loaders def __getitem__(self, i): return self.loaders[i] train, valid = add_props(lambda i, self: self[i])   딱 들어맞는 메서드가 없다면 fastai가 제공하는 데이터블록 사용해 사용자의 상황에 맞는 DataLoaders 객체 생성.\n1 2 3 4 5  bears = DataBlock(blocks=(ImageBlock, CategoryBlock), get_items=get_image_files, splitter=RandomSplitter(valid_pct=0.2, seed=42), get_y=parent_label, item_tfms=Resize(128))     bocks=(독립변수, 종속변수)\n  get_image_files: 인자로 주어진 경로에 포함된 모든 이미지 목록 찾아 반환\n  splitter=RandomSplitter(valid_pct=0.2, seed=42)\n seed: 목록이 시작되는 지점. 난순을 생성하는 기준값이 매번 바뀌기 때문에 주피터 노트북을 실행할 때마다 각 데이터셋에 포함된 이미지가 달라지는 문제 해결하기 위해 제시됨.    get_y=데이터셋 레이블링에 쓰일 함수\n parent_label: 파일이 저장된 폴더명 반환    item_tfms: 모델을 학습시킬 이미지를 텐서로 구성하려면 모든 이미지의 크기가 같아야 한다. 이미지의 크기를 똑같이 맞추는 변형방법.\n  1  dls = bears.dataloaders(path)   배치 요소 중 일부 확인\n1  dls.valid.show_batch(max_n=4, nrows=1)   이미지 크기를 동일하게 맞추려 잘라내다가 일부가 유실될 수도 있다. 이미지를 잘라내지 않고 크기를 맞추는 다음 방법들이 있다.\n 찌그러뜨리기  1 2 3  bears = bears.new(item_tfms=Resize(128, ResizeMethod.Squish)) dls = bears.dataloaders(path) dls.valid.show_batch(max_n=4, nrows=1)   빈 곳을 0으로 채우는 방법  1 2 3  bears=bears.new(item_tfms=Resize(128, ResizeMethod.Pad, pad_mode=\u0026#39;zeros\u0026#39;)) dls=bears.dataloaders(path) dls.valid.show_batch(max_n=4, nrows=1)   위의 두 방법은 이미지를 비현실적으로 변형해서 모델이 실제와는 다른 형태를 학습할 수도 있다. 이미지 크기를 맞추기 위해서 이미지 일부를 잘라내거나, 찌그러뜨리거나, 늘리기, 불필요한 빈 공간을 많이 만들어내는 방법은 모델의 계산 처리에 큰 낭비를 야기시킨다. 이는 유효해상도가 낮아지는 결과로 이어질 수 있다.\n실전에서는 이미지의 특정 부분을 무작위로 선택하여 잘라내는 방식을 보편적으로 사용한다. 에포크마다 무작위로 각 이미지의 다른 부분을 선택해 모델이 각 이미지의 서로 다른 위치에서 드러난 특징에 집중하여 다양성을 인식할 수 있는 방향으로 학습될 수 있도록 한다.\n1 2 3  bears = bears.new(item_tfms=RandomResizedCrop(128, min_scale=0.3)) dls=bears.dataloaders(path) dls.train.show_batch(max_n=4, nrows=1, unique=True)   min_scale: 매번 이미지의 얼마나 많은 영역을 선택할지 결정!\nshow_batch함수의 unique인자: 동일 이미지에서 반복해서 적용되는 변형으로 만들어지는 서로 다른 이미지 확인\n데이터 증강 입력 데이터를 임의로 변형해 새로운 데이터를 생성하는 기법. 변형된 결과들은 서로 다른 개체를 만들지만, 데이터 자체의 의미를 벗어나서는 안된다.\n 회전 뒤집기 원근 뒤틀기 명도 바꾸기 채도 바꾸기..등  1 2 3  bears = bears.new(item_tfms=Resize(128), batch_tfms=aug_transforms(mult=2)) dls = bears.dataloaders(path) dls.train.show_batch(max_n=8, nrows=2, unique=True)   batch_tfms: GPU에서 배치 단위로 적용할 변형 지정하는 인자\naug_transforms: 자연스러운 사진에는 이미 잘 작동한다고 알려진 표준적인 데이터 증강 목록 반환\n모델 훈련과 훈련된 모델을 이용한 데이터 정리 1 2 3  bears = bears.new(item_tfms=RandomResizedCrop(224, min_scale=0.5), batch_tfms=aug_transforms()) dls = bears.dataloaders(path)   1 2  learn = cnn_learner(dls, resnet18, metrics=error_rate) learn.fine_tune(4)   출력:\n epoch train_loss valid_loss error_rate time     0 1.156789 0.205025 0.078431 00:31     epoch train_loss valid_loss error_rate time     0 0.089115 0.056106 0.039216 00:31   1 0.086506 0.044664 0.019608 00:30   2 0.071595 0.076065 0.019608 00:30   3 0.060480 0.062316 0.019608 00:30    1 2  interp = ClassificationInterpretation.from_learner(learn) interp.plot_confusion_matrix()   오차행렬:\n오류가 발생하는 곳 원인 파악해야 데이터셋인지, 모델 자체 문제인지 알 수 있다.\n손실 기준으로 이미지 정렬해서 확인하기\n1  interp.plot_top_losses(5, nrows=1)   ImageClassifierCleaner로 시각적으로 확인해서 데이터 정제 ⚠️ Colab환경에서 실습할 때 ImageClassifier not found Error 발생할 수 있다.\nFastai2’s ImageClassifierCleaner to clean image data is not showing up in Colab 참고해 위젯 모듈을 임포트 해줘야했다. fastai2가 아니라 fastai로 해야 문제가 없었다.\n1  from fastai.vision.widgets import *   1 2  cleaner = ImageClassifierCleaner(learn) cleaner   위젯으로 확인했을 때, 라벨링이 잘못되어 있는 이미지는 레이블을 바꿔주거나 삭제. ImageClassifierCleaner가 해당 이미지를 실제 삭제하거나 레이블을 변경하지는 않는다. 변경이 필요한 목록의 색인번호를 반환한다.\n1  for idx in cleaner.delete():cleaner.fns[idx].unlink()   삭제를 선택한 모든 이미지 삭제.\n1  for idx, cat in cleaner.change(): shutil.move(str(cleaner.fns[idx]), path/cat)   레이블 변경을 선택한 모든 이미지 알맞은 범주의 디렉터리로 옮긴다.\n모델을 온라인 애플리케이션으로 전환하기 먼저, 학습한 모델 파일 형태로 서버에 저장한다. 모델은 구조, 학습된 파라미터로 구성된다.\n1  learn.export()   모델의 구조 및 파라미터 파일로 저장\n1 2  path = Path() path.ls(file_exts=\u0026#39;.pkl\u0026#39;)   확인:\n(#1) [Path('export.pkl')]  추론 모델을 예측에 사용하기\n1  learn_inf = load_learner(path/\u0026#39;export.pkl\u0026#39;)   1  learn_inf.predict(\u0026#39;images/bear.jpg\u0026#39;)   결과:\n('grizzly', TensorBase(1), TensorBase([9.1902e-08, 1.0000e+00, 5.0465e-07]))  (예측된 범주, 예측된 범주의 인덱스, 범주 별 확률)\n1  learn_inf.dls.vocab   DataLoaders의 vocab에 저장된 모든 범주 목록 순서 확인\n['black', 'grizzly', 'teddy']  범주 인덱스도 맞게 된 것을 확인할 수 있다.\n어플리케이션에 모델 서빙 predict 메서드로 모델 예측 기능을 만들어서 구동해봅시다. 간단하게 주피터 노트북에서 위젯으로 웹 어플리케이션을 만들어볼 수 있다.\n 예측하고 싶은 이미지 파일 업로드하는 버튼 만들기  1 2  btn_upload = widgets.FileUpload() btn_upload   FileUpload(value={}, description='Upload')  업로드한 이미지 확인하기\n1  img = PILImage.create(btn_upload.data[-1])   1 2 3 4  out_pl = widgets.Output() out_pl.clear_output() with out_pl: display(img.to_thumb(128, 128)) out_pl   이미지 확인\n해당 이미지에 대한 예측 실행\n1  pred, pred_idx, probs = learn_inf.predict(img)   Label 위젯으로 예측 결과 출력하기\n1 2 3 4  lbl_pred = widgets.Label() lbl_pred.value = f\u0026#39;Prediction: {pred}; Probability: {probs[pred_idx]:.04f}\u0026#39; lbl_pred   출력:\nLabel(value='Prediction: grizzly; Probability: 1.0000')  예측하기 버튼 만들기  1 2  btn_run = widgets.Button(description=\u0026#39;Classify\u0026#39;) btn_run   Button(description='Classify', style=ButtonStyle())  클릭 이벤트 핸들러 정의하기\n1 2 3 4 5 6 7 8  def on_click_classify(change): img = PILImage.create(btn_upload.data[-1]) out_pl.clear_output() with out_pl: display(img.to_thumb(128, 128)) pred, pred_idx, probs = learn_inf.predict(img) lbl_pred.value = f\u0026#39;Prediction: {pred}; Probability: {probs[pred_idx]:.04f}\u0026#39; btn_run.on_click(on_click_classify)   만든 위젯들 나열. GUI 완성  1 2  VBox([widgets.Label(\u0026#39;Select your bear!\u0026#39;), btn_upload, btn_run, out_pl, lbl_pred])   VBox(children=(Label(value='Select your bear!'), FileUpload(value={'스크린샷 2021-11-30 오후 10.25.08.png': …  이상 곰 이미지 분류 모델에 대한 간단한 연습을 해볼 수 있었다.\n","description":"Colab환경에서 fastai로 곰 이미지 분류기 실습","id":27,"section":"posts","tags":["ML","fastai"],"title":"fastai와 파이토치가 만나 꽃피운 딥러닝 2장","uri":"https://www.bemore.dev/posts/ml/fastai/ch2/"},{"content":"github.io 주소도 좋지만 간단하고 나만의 도메인 주소를 만들어서 쓰고 싶었다.\n도메인 구매 구매 사이트 비교(.dev 도메인 비용으로 찾아봤을 때 1년 비용. 기간에 따라 더 비싸지는 곳도 있다고 한다. 구매 전 기간을 설정하고 확인하자.)\n원화 가격은 편의를 위해 만단위로 표시\n   사이트 1년 가격     google domain $12   namecheap $14.98   gandi €14.01   godaddy 2,3890₩   gabia 2,9000₩    이 중 google이니 ad, analytics 사용할 때도 편하지 않을까 하는 기대로 google domain으로 정했다. 그런데 한국은 아직 서비스 하는 지역이 아니어서 결제를 못한다는..? 안내가 있어서 포기했다. 그러다가 역시 구글링을 통해 지역을 바꾸고 진행할 수 있다는 글을 따라 무사히 결제하고 도메인을 받을 수 있었다.\n네임서버 레코드 설정    호스트 이름 유형 TTL 데이터     커스텀도메인 A 기본 185.199.108.153   www.커스텀도메인 CNAME 기본 깃헙계정.github.io    GitHub 저장소에서 도메인 설정 github.io 저장소 \u0026gt; Settings \u0026gt; Pages \u0026gt; Custom domain\n 구입한 도메인 입력 Save 조금 기다린 후 Enforce HTTPS 체크\ngithub.io 저장소에 CNAME 파일이 생성된다.  🎉 완성 이제 내가 설정한 도메인을 이용할 수 있다!\n⚠️ 이후 빌드 커밋하기 전 github.io저장소에 CNAME파일이 생성되었기 때문에 그냥 빌드하고 커밋, 푸시할 때 에러날 수 있다. submodule로 연결되어 있는 public폴더를 미리 업데이트 해주면 문제 없다. 그전에 서브모듈 폴더(public, theme) 내부를 바꾸지 않았어야 한다.\n cd blog git pull: main 프로젝트 pull git submodule update --remote --merge : 연결된 서브모듈들의 업데이트 한번에 받아오기\ngit submodule update --remote \u0026lt;REMOTE-REPO-NAME\u0026gt; --merge: 특정 서브모듈 업데이트만 받아오기  참고자료 Doc\n Hugo doc - Use a Custom Domain\nAbout custom domains and GitHub Pages Managing a custom domain for your GitHub Pages site  Blog\n 블로그 만들기 GitHub 심화 3편 - 커스텀 도메인 블로그 커스텀 도메인 등록하기 Git submodule 사용하기  ","description":"dns주소 설정하기","id":28,"section":"posts","tags":["blog","hugo","개발환경"],"title":"Hugo Blog with Custom Domain","uri":"https://www.bemore.dev/posts/devstory/customdomain/"},{"content":"☘️ 일상을 더 새롭고 재밌게 만드는 개발자가 목표입니다. Project   웹툰 추천 시스템(작업중...🏃)      음악 플레이리스트 추천 2021.08 - 2021.09    Github\nAPI document\n Django 프레임워크 기반 API: 검색, 추천, 노래 재생 링크 연결 SQLite를 활용한 DB구축 AWS 서버 배포      가상 전시회 VARY 2020.04 - 2020.9   Express 프레임워크 기반 API 전시 작품 업로드, 전시관 불러오기, 즐겨찾기 작품 추가, 목록확인\n사용자의 선호 작품을 기반한 전시관 추천    OpenSource  오픈소스 프로젝트: 파이토치 한국어 튜토리얼  파이프라인 병렬화로 트랜스포머 모델 학습시키기 분산 데이터 병렬 처리와 병렬 처리 파이프라인을 사용한 트랜스포머 모델 학습    Act  활동  2019 WISET 멘토활동단: 찾아가는 실험실 2019 2학기 기초전공 튜터링: 튜터 참여 2018 평창 동계 패럴림픽 자원봉사: (SID)관중 접근통제 2018 평창 동계 올림픽 자원봉사: (SID)경기 및 훈련 정보 등 제공 2017 서울동행 교육봉사    ","description":"Back-end developer - Data Engineer","id":29,"section":"","tags":null,"title":"About","uri":"https://www.bemore.dev/about/"},{"content":"SSG(Static site generator) 중 Hugo를 사용하여 블로그를 만들었다. 처음에 뭐가 뭔지 몰라서 뚱땅뚱땅 만들었다. 호스팅까지 하는데 하루 걸렸고 더 빠르게 할 수 있었지만 역시 세팅에서 시행착오를 겪었다. 그나마 Hugo여서 하루만에 할 수 있었던걸수도\u0026hellip; Hugo는 Go로 만들어져서 나중에 Go에 대해서 더 공부해보고 싶다.\ngithub.io 만들기 Hugo 설치하기 brew install hugo\n사이트 폴더 만들기 hugo new site blog\n테마 붙이기 마음에 드는 테마를 찾아서 해당 repo를 submodule로 연결합니다.(보통 해당 repo, docs를 참고)\ncd blog git init git submodule add https://github.com/테마깃주소.git themes/테마이름 Github 저장소 연결 github.io 블로그를 호스팅하기 위해서는 깃헙 저장소 2개가 필요하다.\n blog: 블로그 컨텐츠 깃헙id.github.io: 빌드된 웹사이트  git remote add origin https://blog_저장소_주소 git submodule add -b main git@github.io_저장소_SSH주소 public ## SSH키 있어야함 블로그 사용하기 themes/exampleSite의 content 폴더 내용을 복사해와서 사용.\n 포스트 생성\nhugo new post/포스트제목.md 제목은 title 항목으로 고칠 수 있다.  댓글 기능 추가 깃헙계정으로 댓글을 남길 수 있는 utterances로 설정했다.\n utterances 공식문서를 참고해서 깃헙id.github.io repo에서 앱을 추가 설정파일에서 comment부분이 있다면 설정값 입력!  # comment enableComment = true disqus_shortname = \u0026quot;\u0026quot; commento = false [utterances] # https://utteranc.es/ owner = \u0026quot;깃헙계정\u0026quot; # Your GitHub ID repo = \u0026quot;깃헙계정.github.io\u0026quot; # The repo to store comments 로컬 서버 확인 hugo server (-D) 웹서버 실행해서 수정사항 확인\nhost on github 공식 문서\n1. cd blog 2. hugo -t 테마 3. cd public 4. git add . 5. git commit -m \u0026quot;커밋메시지\u0026quot; 6. git push origin main -\u0026gt; 내계정.github.io에 푸시(main이 기본 브랜치명이었다) 7. cd .. 8. git add . 9. git commit -m \u0026quot;커밋메시지\u0026quot; 10. git push origin master -\u0026gt; blog 저장소에 푸시 쉘 스크립트로 커맨드 줄이기  deploy.sh에 위에 매번 쓰는 커맨드를 정리 이후에 ./deploy.sh \u0026quot;커밋 메시지\u0026quot;만 쓰면 된다  더 간단하게 업로드하는 방법이 있을거 같은데\u0026hellip;Gist, Github Action을 찾아봐야겠다\n추가할 사항  utterances로 댓글기능 추가 GithubAction으로 자동화 Google Analytics custom domain 👉 포스트 테마 바꾸기 👉 포스트  참고 자료 Hugo 공식문서 Quick Start\nHugo로 Github.io 블로그 만들기\nHugo theme Stack doc\n초보자 Hugo 블로그 구축기\n","description":"야 너두 블로그 만들 수 있어","id":30,"section":"posts","tags":["blog","hugo","개발환경"],"title":"Hugo로 개발 블로그 장만하기","uri":"https://www.bemore.dev/posts/first-post/"},{"content":"1. Content-Based filtering: CB  비슷한 아이템을 기반으로 추천\n  도메인 지식 필요 아이템 간의 유사도 측정하여 추천 모든 이에게 동일한 아이템을 추천 보통 아이템, 사용자 수가 적다 hand-engineered features에서만 성능 좋음 텍스트 처리 필요하기도 함(NLP) - 예.작가의 다른 책  핵심\n 아이템들을 어떤 정보를 기준으로 서술할 건가 유사소 계산 방법 정하기 (코사인, 피어슨\u0026hellip;)  2. Collaborative Filtering: CF  기본적으로 다른 사용자들의 정보를 이용하여 취향 예측\n 1) 메모리 기반 (=Nearest Neighbor based CF) - 👨‍👩‍👧‍👦 사용자 기반 나와 비슷한 평점 패턴을 보이는 사람들을 찾아서 그 사람들이 높게 평가한 아이템 추천\n 나와 다른 사람 어떻게 표현할 것인가 나와 비슷한 사용자를 어떻게 찾을지가 중요  사용자 프로파일 정보 구축 프로파일 정보간의 유사도 계산    - 🎨 아이템 기반 아마존에서 논문으로 발표\n유사도 비교 → 평점의 패턴이 비슷한 아이템들을 찾아서 그걸 추천하는 방식\n아이템의 수가 보통 사용자 수보다 적다 → 평점의 수가 평균적으로 더 많고 계산량이 작다 → 사용자 기반보다는 덜 sparse → 사용자 기반 협업 필터링과 비교해 더 안정적이며 좋은 성능을 보임\n2) 모델 기반  넷플릭스 프라이즈 컨테스트 때 고안된 추천 방식 사용자 아이템 행렬에서 비어있는 평점들을 SGD를 사용해서 채우는 방식 SVD(Singular Vector Decomposition)을 사용해서 구현  요즘은 딥려닝의 오토인코더를 사용   평점을 포함한 다른 사용자 행동을 예측하는 방식으로 진화  3) 사용자 행동 기반  사용자 행동(아이템 클릭 or 구매 등) 정보를 기반으로 추천  사용자, 아이템에 대한 부가 정보 필수 구현 간단하지만 아주 유용   사용자 행동을 예측하는 추천 (클릭 or 구매)  모델링을 통해 사용자와 아이템 페어에 대한 클릭 확률 등의 점수 계산 가능  의사 결정 트리나 딥러닝등이 사용 가능 유데미에서 사용했던 방식      4) Latent Factor CF 사용자-아이템 평점 행렬 데이터만을 이용해 말 그대로 \u0026lsquo;잠재 요인\u0026rsquo;을 끄집어 내는 것\n Matrix Factorization 우연한 추천 기능  3. 다수의 알고리즘: 다양한 방식 조합 4. 지도학습 방식 어떤 기준으로 추천을 하느냐가 가장 중요 - 머신러닝의 레이블 정보!\n힌트\n 명시적 힌트: 리뷰점수, 좋아요 암시적 힌트: 클릭, 구매, 소비  클릭보다는 구매가 더 좋은 힌트, 소비 여부도 좋은 힌트다 클릭은 노이즈가 있지만 장점은 관심없는 아이템들의 파악이 쉽다 자세한 사용자 행동 정보의 수집, 저장과 가공 먼저 필요    ","description":"","id":31,"section":"posts","tags":["추천시스템"],"title":"주요 추천 알고리즘","uri":"https://www.bemore.dev/posts/recsys/recsys2/"},{"content":"오픈소스?  공개적으로 액세스할 수 있게 설계되어 누구나 자유롭게 확인, 수정, 배포할 수 있는 코드. Red Hat\n 오픈소스 프로젝트 PyTorch-tutorial-kr\nPyTorch-hub-kr\n파이토치를 처음 공부할 파이토치 한국어 튜토리얼 사이트가 많은 도움이 되었다. 파이토치 공식 문서는 구글과,,,다르게 한국어 지원이 없어서 불편했다. 그렇기 때문에 파이토치 한국어 튜토리얼은 한줄기 빛과 같은 존재였다. 하지만 번역이 진행되지 않은 페이지, 사소한 불편한 점을 나도 함께 개선해 보고 싶었다.\n활동 내용  번역 리뷰 파이토치 튜토리얼 번역 파이토치 허브 문서 번역 번역 규칙 추가  회고 다들 번역 잘하셔서 PR을 리뷰하기 위해서는 여러번 봐야지 작은 부분이라도 찾을 수 있었다. 리뷰하면서도 혹시 틀린 내용이 있을까 더 찾아보고 코멘트를 남겼던것 같다. 번역만 생각했는데 오픈소스 프로젝트를 어떻게 더 잘 운영할 수 있는지, CI/CD, 번역 편의와 일관성, 사용자들에게 정보를 더 쉽게 표현할 수 있을지 등등\u0026hellip; 많은 부분 생각해보는 시간이었다. 참여해보고 싶었던 오픈소스 프로젝트에 참여하는 기본 방법(컨트리뷰션 가이드, 번역규칙 등)부터 차근차근 멘토님이 알려주시고 멘티들과 함께 할 수 있어서 많이 배우고 재밌게 참여할 수 있었다.\n하지만 무엇보다도 내가 작업한 내용이 많은 사람들이 사용하는 오픈소스에 반영된다는 점이 정말 신기하고 신난다..!\n이후 컨트리뷰션 아카데미 기간이 끝나도 해당 프로젝트에서 계속 활동할 예정이다. 이번 기회는 오픈소스 활동을 체험하는 친절한 소개시간이었다고 생각된다. 앞으로도 사용해본 서비스에 대한 오픈소스에 직접 참여할 수 있도록 일상에 최선을 다해야겠다.\n","description":"파이토치 한국어 튜토리얼 참여기","id":32,"section":"posts","tags":["회고","PyTorch"],"title":"오픈소스 컨트리뷰톤","uri":"https://www.bemore.dev/posts/retrospect/contributhon/"},{"content":" 사용자가 관심있어 할만한 아이템을 제공해주는 자동화된 시스템\n  핵심  관심을 어떻게 표현하는가? 관심을 어떻게 측정하는가?\n=\u0026gt; 유사도 측정    사용자와 아이템  사용자: 서비스를 사용하는 사람 아이템: 서비스에서 판매하는 물품(다른 사용자가 물품이 될 수 있음)\n보통 서비스가 성장하면 사용자, 아이템의 수도 같이 성장함  특히 사용자의 성장도가 훨씬 커짐   하지만 아이템의 수가 커지면서 아이템 디스커버리 문제가 대두  모든 사용자가 검색(능동적)을 하지 않으며 사람들이 점점 더 추천(수동적) 선호    필요성  조금의 노력으로 사용자가 관심있어 할만한 아이템을 찾아주는 방법  아이템의 수가 굉장히 큰 경우 더 의미가 있다 수작업으론\u0026hellip;도저히 불가 → 자동화 필요! 개인화(Personalization)으로 연결됨 확증편향의 문제가 있을 수 있다  가끔씩 전혀 관심없을 듯한 아이템도 추천 가능(Serendipity)     회사 관점에서는 추천 엔진을 기반으로 다양한 기능 추가 가능  마케팅시 추천 엔진 사용(이메일 마케팅) 관련 상품 추천으로 쉽게 확장 가능   아이템 수가 많아서 원하는 것을 찾기 쉽지 않은 경우\n⇒ 검색을 위한 수고를 덜어줌 추천을 통해 신상품등의 마케팅이 가능해짐  새로 나온 아이템들은 노출 자체가 어려운데 추천을 통해 기회를 줄 수 있다   인기 아이템 뿐만 아니라 롱 테일의 다양한 아이템 노출이 가능  추천 방식에 따라 다르지만 개인화가 잘 되면 이게 가능해짐    추천은 매칭 문제!  사용자에게 맞는 아이템을 매칭해주기  아이템은 서비스에 따라 달라지며 아이템이 다른 사용자가 될 수도 있음 (친구 추천, 강의 추천\u0026hellip;)   어떤 아이뎀을 추천할 것인가?  다양한 방법이 존재  지금 뜨는 아이템 추천(개인화되어 있지 않음) 사용자가 마지막에 클릭했던 아이템들 다시 추천 사용자가 구매했던 아이템들을 구매한 다른 사용자들이 구매한 아이템 추천 ← 협업 필터링     추천 UI도 굉장히 중요  추천 유닛 존재. 일르 어떤 순서로 어떻게 노출하는지가 중요 구체적인 이유를 보여주는 것이 좋다   사용자와 아이템에 대한 부가 정보들이 필요해짐 아이템 부가 정보  분류 체계 태그 형태로 부가정보를 유지하는 것도 아주 좋음   사용자 프로파일 정보  개인정보: 성별, 연령대 → 콜드 스타트 문제 해결 아이템 정보:  관심 카테고리와 서브 카테고리(분류체계 기반), 태그 클릭 혹은 구매 아이템     무엇을 기준으로 추천을 할 것인가?  일상에서 볼 수 있는 추천  아마존 관련 상품 추천\n키보드 샀다면 → 같이 쓸 마우스 추천 넷플릭스 영화, 드라마 추천\n이전에 봤던 작품 → 다른 드라마, 영화 추천\n추천 타이틀: 이 작품들 왜 추천하는지 구글 검색어 자동 완성\n편리, 내가 생각하지 못했던 정보로도 검색할 수 있어서\n개인정보 이슈가 있었다 링크드인 or 페이스북 친구 추천  사용자: 멤버 아이템: 멤버\n왜 추천하는지 이유를 보여준다   스포티파이 노래, 플레이리스트 추천 헬스케어 도메인의 위험 점수 계산\n사용자: 의사, 간호사\n아이템: 환자\n어느 환자를 먼저 치료하는게 좋은지 점수로 수치화  → 공통점  격자 형태 UI 사용 다양한 종류의 추천 유닛 존재  일부 유닛은 개인화 일부 유닛은 인기도 등 비 개인화 정보기반 추천 유닛의 랭킹 중요  이 부분도 모델링하여 개인화하는 추세 클릭을 최적화하고 이 데이터 수집을 위한 실험을 함  순전히 데이터 수집을 위한 온라인 테스트        ","description":"","id":33,"section":"posts","tags":["추천시스템"],"title":"추천시스템이란?","uri":"https://www.bemore.dev/posts/recsys/recsys1/"},{"content":"AWS 도커 설치 이대로 했는데\n도커 서버가 보이지 않다면 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?\nFix  sudo service docker status: 도커가 inactivate 상태인지 확인 sudo service docker start sudo systemctl enable docker: 리부팅때 자동 실행되도록 설정 sudo usermod -aG docker ec2-user sudo reboot  ","description":"AWS 도커 설치 중 도커 클라이언트는 뜨는데 서버가 보이지 않는경우","id":34,"section":"posts","tags":null,"title":"AWS linux에 도커 설치","uri":"https://www.bemore.dev/posts/whynotwork/aws_docker/"},{"content":" 추천시스템에 관한 프로젝트를 진행하면서 점점 커지는 프로젝트 내용과 설정들, github에 용량 커서 안올라가는 파일들도 있어서 배포할때 어떻게 해야할지 고민이었는데\u0026hellip;\n로컬에서 도커 빌드하기\n 0. gunicon 설치 0-1. pip freeze \u0026gt; requirements.txt 설치 필요한 모듈들 requirements.txt에 모두 쓰기 (도커파일 작성하기전에 확인하기. 버그 고치다가 쓸데없이 설치한 모듈들도 있어서 transformers, tokenizers\u0026hellip;)\n그래도 이런 경우가 생길 수 있으니 링크는 저장해둔다.\nFailed building wheel for tokenizers\nerror: Can not find Rust compiler\ncryptography 오류시 대처법\n1. 도커파일 Dockerfile 작성하기 프로젝트 최상위 경로에 Dockerfile 생성하기.\nvscode로 작업한다면 extention에서 docker를 설치하고 작성하면 가독성이 편하다.\nFROM python:3.8-slim-buster WORKDIR /usr/src/app ENV PYTHONDONTWRITEBYTECODE 1 ENV PYTHONUNBUFFERED=1 ENV CRYPTOGRAPHY_DONT_BUILD_RUST=1 # Required pkgs installation RUN pip install --upgrade pip COPY requirements.txt ./ RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh RUN pip install -r requirements.txt # Port setting EXPOSE 8000 # gunicorn execution CMD [\u0026quot;gunicorn\u0026quot;, \u0026quot;--bind\u0026quot;, \u0026quot;0.0.0.0:8000\u0026quot;, \u0026quot;Web.wsgi:application\u0026quot;] 2. khaiii가 있었구나..! 도커파일 Port setting 전에 다음 내용 추가\n#khaiii RUN apt-get update \u0026amp;\u0026amp; apt-get install -y git build-essential RUN apt -y update RUN apt -y install build-essential locales locales-all WORKDIR /root RUN git clone https://github.com/kakao/khaiii.git WORKDIR /root/khaiii RUN pip install -r requirements.txt WORKDIR /root/khaiii/build RUN cmake .. RUN make all RUN make resource RUN make install RUN make package_python WORKDIR /root/khaiii/build/package_python RUN pip install . RUN locale-gen en_US.UTF-8 RUN update-locale LANG=en_US.UTF-8 khaiii에 기본으로 있던 도커파일을 그대로 쓰면 git부분이나 다른 부분에서 에러가 나서 도커 이미지 빌드가 안될 수 있다. 다음과 같이 필요한 부분을 더 추가한 내용으로 고쳐쓰니 무사히 빌드가 되었다.\n3. 도커파일 빌드 docker build -t 계정/이미지:0.1.1 .\n도커 이미지 확인 docker images\n4. 도커허브에 올리기 docker push 이미지:버전\ndenied: requested access to the resource is denied  docker login 이미지 이름에 도커허브 계정이 빠졌다면\n잘못된 이미지 이름 바꾸기  도커허브에서 이미지 받기 docker pull 이미지:버전\n이미지 실행 docker run -d -p 8000:8000 내계정/django_web:0.1.1\n실행 확인 docker ps\n중지 docker stop id일부\n삽질⛏ COPY는 RUN처럼 \u0026amp;\u0026amp;을 사용할 수 없다 ","description":"도커 생각보다 안 어려워요~","id":35,"section":"posts","tags":["docker","django"],"title":"Django 프로젝트 도커 이미지 생성하기","uri":"https://www.bemore.dev/posts/devstory/docker_build/"},{"content":" 플레이리스트에 추천 곡을 채워주는 서비스를 작업중\n 모델파트에서 모델파일이랑 필요한 부분을 주셔서 장고 웹에 붙이기만 하면되는데\u0026hellip;생각보다 빨리 진행되지 않았다. 그 이유는\u0026hellip;\nModuleNotFoundError: No module named \u0026lsquo;Utils\u0026rsquo; [Pytorch torch.load -\u0026gt; ModuleNotFoundError: No module named \u0026lsquo;utils\u0026rsquo;]\n(https://stackoverflow.com/questions/65538179/pytorch-torch-load-modulenotfounderror-no-module-named-utils)\nUtils로 된 폴더 명이 겹쳐서 그런줄 알고 바꿨는데도\u0026hellip;Utils라고 계속 뜨길래 대체 뭐지? 했는데\ntorch.save했을때 쓴 Util 모듈과 같은게 있어야 하는거 같다.\n1.Utils 폴더에 필요한 파일 생성 2. khaiii 설치 khaiii 깃허브\nkhaiii 형태소 분석기에 설치 방법\n프로젝트 배포할때는 도커 써야겠다\u0026hellip;\ngensim 설치 pip install gensim\n이제 돌릴 수 있나?! module notfound는 이제 없지만\u0026hellip;\nRuntimeError: Attempting to deserialize object on a CUDA device but torch.cuda.is_available() is False. If you are running on a CPU-only machine, please use torch.load with map_location=torch.device('cpu') to map your storages to the CPU. [31/Aug/2021 13:12:03] \u0026quot;POST /playlist/recommend HTTP/1.1\u0026quot; 500 132085 ㅎㅎ\u0026hellip;\n추가 실행 오류 디바이스 cpu로 설정하고 했을때 보이는 오류들\u0026hellip;cuda가 답인가\n tqdm: \u0026lsquo;module\u0026rsquo; object is not callable KeyError: 4 TypeError: dropout(): argument \u0026lsquo;input\u0026rsquo; (position 1) must be Tensor, not str\npip install transformer==3 불러올 파일 빠트리기ㅎ\u0026hellip;팀원분의 도움으로 금방 찾을 수 있었다. 진작 물어볼걸! Error: Expected more than 1 value per channel when training  model.eval()로 해결할 수 있다.    드디어 실행 성공 온갖 에러를 다봤다\u0026hellip;금방 끝날 줄 알았지ㅎ\u0026hellip;\n","description":"모델을 만들었는데 왜 쓰질 못하냔 말이야...","id":36,"section":"posts","tags":null,"title":"파이토치 모델 불러오기","uri":"https://www.bemore.dev/posts/whynotwork/model_serving/"},{"content":"When? 파이토치 모델 서빙하기 위해 예시를 보다가 이미지 분류 장고 웹을 볼 수 있었다. 로컬에서 돌러보고싶어서 클론하고 requirements.txt로 필요한 모듈들을 다운받았다. 하지만 django manage.py runserver후 모듈관련 에러메시지가 보였다.\ndjango.core.exceptions.ImproperlyConfigured: WSGI application 'application' could not be loaded;\nFix  pip install django-cors-headers pip install whitenoise  참고 django.core.exceptions.ImproperlyConfigured: WSGI application \u0026lsquo;application\u0026rsquo; could not be loaded\n","description":"","id":37,"section":"posts","tags":null,"title":"Django runserver 에러","uri":"https://www.bemore.dev/posts/whynotwork/django_runserver/"},{"content":" Github) PyTorchKR\n nvm: command not found 노드 버전관리 설치 및 사용법\n find ~/.zshrc로 /.zshrc파일 있는지 확인 open ~/.zshrc 파일 열어서 아래 내용 추가  export NVM_DIR=~/.nvm source $(brew --prefix nvm)/nvm.sh source ~/.zshrc 코드 적용 nvm \u0026ndash;version으로 확인  rbenv: version `2.5.9' is not installed brew install rbenv했지만 [이걸 또 m1이..?]\n(https://github.com/rbenv/ruby-build/issues/1691)\n해결 방법은 간단했습니다.\nrbenv install 2.5.9\nERROR: While executing gem\u0026hellip;Gem::FilePermissionError Mac에서 Gem::FilePermissionError 에러 발생시 해결 방법\n~/.zshrc 파일에 아래 내용 추가\n[[ -d ~/.rbenv ]] \u0026amp;\u0026amp; \\ export PATH=${HOME}/.rbenv/bin:${PATH} \u0026amp;\u0026amp; \\ eval \u0026quot;$(rbenv init -)\u0026quot; source ~/.zshrc로 코드 적용\nbundle install 에서 make: yarn: No such file or directory npm install -g yarn\n빌드 make serve\n멘토님의 친절한 커맨드 예시와 오늘도 구글링으로 얻은 정보들에 감사하며\u0026hellip;🥳\n","description":"간단한 빌드 중 만나게 되는 에러들^^*","id":38,"section":"posts","tags":["M1","오픈소스","개발환경"],"title":"파이토치 허브 M1 로컬에서 빌드하기","uri":"https://www.bemore.dev/posts/devstory/torchhub_m1/"},{"content":"스터디에서 4주 동안 배운 알고리즘 유형 문제를 정해진 시간에 풀어보는 모의 코딩테스트를 진행하고 싶었다. 백준 문제를 배운 알고리즘 내에서 랜덤으로 출제하는 슬랙 챗봇을 사용하면 재밌을거 같았다. 백준 사이트는 웹 스크래핑이 금지된다고 공지가 되어있어 solved.ac의 알고리즘 유형 카테고리 정보를 긁어오는 식으로 문제를 뽑아왔다. 혹시 이것도 문제가 되는지 문의해봐야겠다\u0026hellip;\n사용 라이브러리  BeautifulSoup slack_sdk  데이터 긁어오기 출제 유형 랜덤 선택, 문제 랜덤 선택 tag의 랜덤 범위가 5인 이유는 5개 알고리즘을 배워서\u0026hellip;\n슬랙에 텍스트 보내기 Slack api \u0026gt; create app\nSending messages 문서\n원래 slacker 모듈을 사용했는데 적용이 안되어서 찾아보니 21년부터 slacker는 지원하지 않고 slack_sdk 패키지를 사용하는 것 같다.\n문제 상황 🤔 백준 사이트는 지나치게 많은 트래픽을 발생시키는 경우에는 사이트 이용이 정지된다고 합니다. 백준 사이트가 아닌 solved.ac의 알고리즘별 문제 목록을 긁어오는 것도 그래서인지 여러번 실행하면 아무 정보가 들어오지 않는다. 하지만 solvedac인데 왜..?\n개선해야할 점 지금 상태는 파이썬 코드를 직접 실행시켜야 슬랙 챗봇이 실행된다. 파이썬 메인함수에서 스터디 기간동안 배운 알고리즘 유형들을 solved.ac에 있는 tag이름으로 찾아서 써줘야한다. 외부에서 간단하게 입력할 수 있었으면 좋겠다. 또한 다른 슬랙 앱처럼 슬랙에서 바로 실행시킬 수 있도록 할 필요가 있다.\n[참고 사이트] https://yganalyst.github.io/web/slackbot1/\nhttps://corikachu.github.io/articles/python/python-slack-bot-slacker\nhttps://github.com/os/slacker\nhttps://api.slack.com/authentication/oauth-v2\nhttps://developerdk.tistory.com/96 슬랙커가 안먹히는 이유\nhttps://api.slack.com/methods/chat.postMessage/code\nhttps://slack.dev/python-slack-sdk/v3-migration/index.html#from-slackclient-2-x\nhttps://pypi.org/project/slack-sdk/\nhttps://pythonrepo.com/repo/slackapi-python-slack-sdk-python-third-party-apis-wrappers\nhttps://github.com/slackapi/python-slack-sdk/issues/561\n","description":"","id":39,"section":"posts","tags":["chatbot"],"title":"SlackBot으로 랜덤 문제 출제","uri":"https://www.bemore.dev/posts/devstory/slackbot1/"},{"content":"여러 파이썬 파일로 모듈을 구성하고 이를 연결할때 ModuleNotFoundError: No module named 모듈 에러를 확인하면 당황스러울 수 있다. 왜냐하면 이전까지 아무 생각 안하고 썼을때는 문제가 없었는데!\n처음에는 vscode 환경에서 경로를 따로 설정해줘야 하는지 찾아보았다.\n두 번째는 가상환경에서 파이썬 경로가 다른건가 생각했다.\n다른 프로젝트를 열어서 스크립트 두개를 만들어 확인해보니 문제가 없었다. 다시 작업하던 프로젝트로 돌아와 같은 테스트를 해보니 잘 돌아갔다! 여기서 알게 된 것은 같은 폴더였다는 것이다. 불러올 모듈이 다른 경로에 있으면 from 모듈로 찾을 수 없던 것이다.\n참고\n파이썬이 import한 모듈과 패키지를 찾는 과정\n파이썬 상위폴더, 하위폴더에 있늠 모듈 불러오기\n다른 경로에 있는 모듈을 불러오고 싶다면 /는 사용하지 않고 .으로 하위 경로를 표시할 수 있다\nfrom 폴더.모듈 import 메서드\n예)\nfrom dataLoad.arena_util import json_load\n","description":"","id":40,"section":"posts","tags":null,"title":"ModuleNotFoundError: No module named 모듈","uri":"https://www.bemore.dev/posts/whynotwork/python_modulenotfound/"},{"content":"1. iTerm2 설치 brew install --cask iterm2\n2. Powerlevel10k 권장 폰트 설치 설치한 다음 iterm-\u0026gt; 폰트 설정에서 MesloLGS NF 선택\nvscode 콘솔에서 프롬프트가 깨지는 문제가 있었는데 이부분도 폰트를 추가해줘야 해결된다\n3. Powerlevel10k 설치 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k echo 'source ~/powerlevel10k/powerlevel10k.zsh-theme' \u0026gt;\u0026gt;~/.zshrc 원래 이거 전에 Oh-My-Zsh 설치인거 같은데 매뉴얼 따라하다가 테마 먼저 받은거 같다\u0026hellip;\n4. Oh-My-Zsh git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 5. 테마 설정  source ~/powerlevel10k/powerlevel10k.zsh-theme: 초기설정 p10k configure: 실행하면 다시 설정할 수 있다  참고 Powerlevel10k 공식\n맥 터미널 환경 세팅\n설치 순서\nPowerlevel10k로 zsh 설정하기-outsider\n","description":"밋밋했던 터미널 이젠 안녕~","id":41,"section":"posts","tags":null,"title":"터미널 꾸미기","uri":"https://www.bemore.dev/posts/devstory/terminal/"},{"content":"Homebrew? 그냥 사이트에서 다운받는거랑 뭐가 다른가요?\nmacOS용 패키지 매니저로 프로그램 설치, 업데이트, 삭제를 편하게 관리할 수 있다. (하지만 윈도우만 쓰던 나는 나중에 알았다..)\nM1 네이티브로 설치하려 했으나..실패! 그냥 뭔가 커맨드가 안먹혀서 의문이었는데 기존 MAC을 위한 안내는 기존 실리콘칩. 내 컴퓨터는 m1칩이라 그런 것이었다.\n🛠해결 M1 네이티브로 설치하는 방법도 있으나 이전 맥 터미널과 동일하게 호환할 수 있는 Rosetta를 사용하는 방법이 제일 간단했다.\n 터미널앱 \u0026gt; 정보 가져오기\u0026gt; ☑️ Rosetta를 사용하여 열기 Homebrew 설치\n/bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot;  참고\n설치하기 이전에 이걸 봤어야 했는데\u0026hellip;\n","description":"M1...","id":42,"section":"posts","tags":["M1","homebrew","개발환경"],"title":"MacMini M1 에서 Homebrew 설치","uri":"https://www.bemore.dev/posts/devstory/macmini_brew/"},{"content":"코로나 이\u0026hellip; 미친 코로나 때문에\u0026hellip; 1년이 날아간 기분이다. 주어진 처지에서 최선을 다했으니 후회는 없지만 그래도 아쉬움이 없는 것은 아니다.\n졸업 프로젝트 졸업 프로젝트때 되면 선배들처럼 엄청난걸 척척 해낼 줄 알았다. 하지만 나는 여전히 똑같았다\u0026hellip; 더군다나 코로나로 대면수업도 못하는데 팀 프로젝트를 진행하려니 심란했다. 그나마 다행인건 친한 동기들과 해서 모임 약속 잡는게 수월했다. 프로젝트 하면서 내 이상과 현실이 같지 않아서 마치 더닝크루거 그래프의 절망의 계곡에서 허덕였다. 화상 회의 프로그램을 잘 활용하는 것이 코로나 속에서 팀플하는 사람에게 미덕이 될 수 있었다. 협업 툴을 내가 좀 더 잘 다룰 수 있었다면 협업할 수 있었을 거같다. 계획을 가지고 찬찬히 공부했다면 좀더 헤메지 않았을거 같지만 조급하고 막막했다.\n심리학 생리심리학을 공부하면서 뇌구조에 배웠다. 뇌는 정말 흥미롭다. 전뇌, 중뇌, 후뇌\u0026hellip;전두엽, 두정엽, 측두엽, 후두엽\u0026hellip;전전두피질, 연합피질 등 뇌의 세부적인 부위와 그 기능을 알 수 있었다. 제제교수님 안식년 가시기 전에 강의 다 들어두려고 수강신청도 성공하고 재밌게 공부했던 것 같다. 강의 ppt는 가로측으로 넘기는거라 상하관계가 잘 정리되지 않아서 노션 토글버튼으로 편하게 필기(?)하면서 복습했다. 뇌를 공부하면서 인간의 사고방식과 컴퓨터 동작 구조와 유사한 점이 많았다. 아마 인지심리학의 접근법이 컴퓨터과학과 비슷하기 때문이라 생각한다. 학습심리학은 머신러닝에도 쓰이는 이론들이 많아서 재밌었다. 하지만 시험이 즐겁진 않았다\u0026hellip;\n학문은 다 연관되어 있다. 모든 분야는 다른 분야를 발전시킬 수 있다🌱\n","description":"다사다난한 졸업학년...","id":43,"section":"posts","tags":["회고"],"title":"2020년 회고","uri":"https://www.bemore.dev/posts/retrospect/y2020/"},{"content":"운동🏃 태권도. 8월까지 방학에는 태권도장에 다니면서 처음보다 확실히 좋아졌다. 하지만 학기 중에 운동을 위해 집에 자주 오는 것도 부담되서 2학기에 소모임을 만들어 주 3회 운동하려고 했으나\u0026hellip;모임을 지속적으로 유지하는 것도 쉽지 않았고 내가 유단자가 아니어서 역량도 없는 상태였다. 회비를 걷지 않고 자율적인 참여여서 참여율은 많이 떨어졌지만 금전 문제가 없는 것이 차라리 다행이었다. 이렇게 부족한 소모임 운영이었지만 참여해준 모든 모임원들에게 정말 고마울 뿐이다. 특히 그냥 모임원이었는데 운영자보다 더 많은 부분 맡아야했던 다른과 후배님,,,나와 같은 초급자들 기본자세, 품새를 가르쳐줬다. 같이 운동하는게 즐거워서 하는 사람을 만나서 좋았던 기회였다. 막판엔 거의 못했지만 지속적으로 한 운동은 수영 이후로 처음이다. 체력에 대해서 많이 필요하다고 생각했던 한 해였고 체력을 기르기 위해 나름의 노력을 했는데도 어려웠다. 아쉬움이 더 많이 남는다. 이번에 6개월 꾸준히 했던 거라면 내년에는 12개월을 꾸준히 운동하고 그렇게 된다면 태극5~8장도 잘하게 된 상태를 만들고 싶다.\n학교 1학기는 휴학하는 동안 무엇을 공부하고 싶은지 정하고 공부가 필요하다는 생각이 있어서 힘들지 않았다. 통학하다 기숙사에 들어갔더니 2시간에서 10분으로 줄어든 통학시간을 만끽할 수 있었다. 반면 2학기는 태권도 소모임 진행도 일주일에 2번 이상이고 튜터링으로 3학점 수업을 8개 듣는 느낌이었다. 계획도 부실했고 시간을 관리하는 모습이 아니라 시간이 미친듯이 달려 내가 이리저리 휘둘리는 기분이었다. 특히 화,목 하루 4연강에 기말고사만 시험보는 과목이 4개였는데 다시는 그런 선택을 하고 싶지 않다\u0026hellip;\n심리학 심리학을 공부하기로 한 것은 인간의 사고과정이 어떻게 작동하는지 알 수 있다면 인공지능을 공부하는데 도움이 될거 같아서 선택하였다. 그리고 내 기분이 형성되는 과정이 어떤 생물학적 성분과 연관되는지 배우는 것도 재밌어 보였다. 아직 5과목 들어본 상태지만, 적성에 잘 맞는 것 같다. 심리학과는 학점따기 많이 힘들다고 들어서 두려웠지만 도전한 것이 답이었다. 3학년때 심리학 전공을 듣기 시작해서 복수전공은 시간적으로 어려워 부전공으로 공부하지만 늦게라도 내가 정말 공부하고 싶었던 것을 찾아서 행운이다. 물론 공부하다가 힘든 점은 있었다. 전공 공부보다 적성에 맞는다고 해서 그 학문이 쉽다는건 절대 아니었다. 다른 타입의 어려움을 많이 느꼈던 2학기였다.\n활동   머신러닝 스터디: 휴학하는 동안 빅데이터, 블록체인, VR\u0026hellip; 새롭게 나오는 개념들을 얕게만 배웠는데 머신러닝은 배워보지 않은 부분이었다. 구글에서 제공하는 스터디잼을 신청해서 코세라, 콜랩을 이용할 수 있었는데 몰아서 듣느라 잘 활용하지 못했다. 통계 그래프 설명이 있었는데 상관계수(correlation coefficient), 회귀분석(regression)라는 용어도 잘 몰랐다. 심리통계연구법 강의를 듣고 나서야 알 수 있었다. 내년에도 구글 스터디잼이 열렸으면 좋겠다. 아는 만큼 들리는 거였나 보다.\n  와이즈센터 교육봉사: 1학기, 여름방학에 영등포 여고로 가서 코딩실습 수업을 돕는 활동이었다. 고3이 이렇게 밝을 수 있다는 것을 처음 봤다. 대학교 1학년때 들었던 실기 수업보다 더 유익한 수업이었다. 나도 코딩을 이렇게 처음 접했더라면\u0026hellip;이라는 헛된 생각을 했었다.\n  튜터링: 기존 학과 튜터링이었으면 4점 대가 아닌 나는 학점미달로 신청도 못했을거다. 하지만 파이썬으로 튜터도 공부하면서 따라갈 수 있다고 되어있어 도전했다. 운이 좋게(?) 인원 미달이었고 2명의 튜터가 한 반씩 맡아 과제시간을 진행했다. 개념을 가르치는 것보다는 매주 과제가 나오면 후배들의 질문에 필요한 파이썬 개념이나 함수들을 알려주거나 에러메세지를 읽고 답해주는 일이었다. 수업을 준비하면서 더 많이 배웠다. 초반에는 내가 문제 풀면서 어려운 점이 없어서 널널하게 갔다가 질문이 많아 당황한 적이 있었다. \u0026lsquo;소수 구하기\u0026rsquo;, \u0026lsquo;반복문 예제\u0026rsquo;들을 반복해서 풀었던 경험이 있어 자동을 풀었던 거지만 그 문제를 처음 봤을 때는 낯설고 어려웠던 것을 잊었던 것이다. 이후에는 교수님이 보내주신 수업 피피티와 문제들을 푸는 것은 짧았지만 질문을 예상하고 어디에 중점을 둬서 설명할지, 더 쉽게 알려주고 싶어서 연습했다. 매주 튜터링이 끝나고 더 잘 설명하지 못한게 아쉽고 다음주에는 더 준비해야겠다는 생각이 들었다. 열심히 하는 후배들을 보면서 뿌듯하면서도 이 친구들의 시작이 내 시작보다 좋다는 부러움, \u0026lsquo;1학년때 질문하는 것을 왜 그리 어려워했을까\u0026rsquo; 후회했다. 당시에는 남들은 다 빨리 푸는데 나는 아직도 앞에 문제도 못 풀고 질문하는게 무의식적으로 부끄러워 알아서 해결하려고 했고 제대로 질문하는 것도 몰랐고 대답을 들어도 이해를 못했다. 막상 선배로서 질문을 받아주는 역할이 되니 질문을 많이 하는 후배가 귀찮은게 아니라 나도 질문을 받으면서 더 많이 알아갈 수 있는 기회였다. 문제에 직면했을때 자신이 어떤 시도를 해봤고 결과가 나온 것에서 나아가기 위해서 무엇이 필요한지 묻는 질문에는 칭찬을 하고 싶었다. 튜터링을 하면서 여러사람이 쓴 코드를 볼 수 있었고 에러메시지를 읽고 문제 부분을 먼저 파악하고 빠르게 각 변수, 함수가 무엇인지 보고 에러를 찾는 과정은 일종의 순발력을 키울 수 있는 시간이었다. 끝으로 파이썬을 표현하자면 \u0026lsquo;이게 되네..?!\u0026lsquo;였다.\n  모각코: 10월부터 12월까지 매주 토요일 9시에 강남에 모여 각자 코딩하는 시간이었다. 기숙사 급식 챗봇을 카카오톡으로 만드는 것이 목표였다. 하지만 카카오플러스가 유료화 된 시점이었고 다른 메신저에 크롤링한 결과를 보내는 것이 생각만큼 간단하지 않았다. 초반 작업만 빨랐고 그 다음부턴\u0026hellip; 그래도 개발직군에서 일하는 분들을 가까이 만날 수 있는 기회였고 다들 좋은 분들이었다. 목표가 있고 그것을 위해 구체적인 노력을 쏟는 사람들이 모인 자리에서 많은 에너지와 정보를 얻을 수 있었다. 나 혼자였으면 몰랐을 기술 서적, 세미나, 좋아보이는 개발자 문화에 대해 알 수 있었다. 수업이나 과제때문에 하는 개발이 아니라 내가 필요해서, 해보고 싶어서 하는 코딩이 재밌다는 것을 처음 느꼈다. (지속기간 3주였지만..)\n  세미나  우먼테크메이커스 슬기로운 인턴 생활 플러터 위민후코드 연말 행사  느낀 점 시간이 정말 빠르다. 올해의 가장 중점은 휴학 생활이 끝나고 학교로 돌아가 학교 공부에 집중하는 거였다. 학교를 다니면서 수업을 듣고 과제를 하고, 시험만 보는데도 정신 없었고 어느새 1년이 마무리 되었다. 학점관리는 원하는 만큼 나왔는데 다시 생각해보니 강의에서 수업이상으로 추구하는 의미가 있는데 당시 나는 성적에 얽매여서 그 의미를 제대로 보지 못했던 것 같다. 그만큼 좋은 강의를 들었던 학기였다. 올해 가장 큰 수확은 기숙사에 들어간 것과 아이패드이다. 기숙사는 그동안 통학했던 내 고통이 보상받는 기분이다. 아이패드는 노트북만큼 좋다. ios는 처음 사용하는데 더 편한 기능들도 있고 새로운 앱 보는 것도 재밌다.\n내년엔  운동: 태권도 꾸준히 졸업 프로젝트 잘 끝내기 인턴 책 50권  ","description":"복학 라이프","id":44,"section":"posts","tags":["회고"],"title":"2019년 회고","uri":"https://www.bemore.dev/posts/retrospect/y2019/"},{"content":"이 책은 저명한 역사가, 철학자, 지식인의 논리는 인용한 다음 이를 반박하는 형식으로 서술된다. 또한 저자가 당시 옥스퍼드 교수로 학부생들을 대상으로 강의한 내용을 옮겨놓은 책이기 때문에 영국의 역사, 정치, 문화, 당시의 분위기를 모르고 패기롭게 읽으니 중후반에는 문장을 읽다가 길을 잃는 느낌이었다. 역사를 읽기 전에 역사가가 살았던 배경을 아는 것이 먼저였던 것처럼 이 책 또한 저자와 그가 살았던 배경에 대한 이해가 필수라는 것을 점점 체감할 수 있었다.\nE.H.카는 ’있는 그대로의 사실만을 기록해야 한다’라는 랑케의 실증주의를 전면으로 반박한다. 나는 이전까지 ‘역사가가 과연 있는 그대로의 사실만을 기록할 수 있을까?’라는 의문조차 생각하지 않고 역사를 배웠다. ‘역사상의 사실은 기록자의 마음을 통해서 굴절되어져 온다.’ ‘사회는 개인으로 구성되지만 개인 또한 사회의 영향을 받는다.’ 이 관점을 항상 기억하려고 한다. 이를 통해 내 사고의 영역에 있는지도 몰랐던 장벽을 하나 제거할 수 있었던 것 같다.\n실증주의 아래 쓰여진 객관적인 역사를 쓸 것이라고 기대하던 모습들이 마치 오늘날 인공지능을 바라보는 시각과 비슷하다고 느껴졌다. 완전무결한, 객관적이며 알고리즘을 통해 공정한 정보만을 제공할 거라고 맹신했지만 머신러닝 이론 책에서는 항상 데이터에서조차 보이는 불평등을 지적하며 이러한 맹신이 위험하다는 것을 당부한다. 역사가가 선택하는 사료처럼 개발자가 다루는 데이터, 알고리즘 또한 그 소스는 인간이 만든 것이다. 역사도 항상 ‘왜?’라는 의문을 가지고 바라봐야 한다. 서술된 역사뿐만 아니라 그 역사를 서술한 역사가에게도 ‘왜?’라는 의문을 가져야 한다.\n역사 속 우연에 대한 생각을 다시 하게 되었다. 이전에는 역사의 흐름이 우연으로 판가름 될 수 있다고 생각했다. 물론 일상에서처럼 역사에서도 우연은 존재하며 그 순간이 촉매제가 될 수 있다. 하지만 그 순간만으로 결정될 수 없다. 기발한 인물이나 특수한 우연으로 역사를 설명할 수 있다는 것은 매우 편리한 만큼 위험하다. 거대한 흐름이 한순간에 결정되었다는 논리는 너무 흥미로워 그 뒤의 탄탄한 서사를 무시하게 된다. 역사적 과오에 대해서도 우연을 탓하거나 개인을 탓하는 것이 가장 쉬운 방법이지만 이런 태도라면 아무것도 남지 않는다. 이를 통해서 항상 아쉬운 역사 속 순간에 대한 가정법을 그만둘 수 있었다.\n이제는 다양한 시각으로 역사상의 사실을 다룰 수 있는 시대라고 생각한다. 세상이 변하는 것처럼 역사도 변할 것이라고 생각한다. 더 다양한 역사를 보고 싶다. 변화하는 것은 낯설고 두렵고 고통스러울 수 있다. 그럼에도 그것은 움직인다.\n","description":"","id":45,"section":"publication","tags":null,"title":"역사란 무엇인가","uri":"https://www.bemore.dev/publication/book/whatishistory/"}]